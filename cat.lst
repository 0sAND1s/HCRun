# file opened: D:\Spectrum\src\HC\HCRun\cat.ASM
   1  0000              ;File listing program for HC
   2  0000              ;George Chirtoaca, george.chirtoaca(@)gmail(.)com, March 2022
   3  0000              ;
   4  0000              ;The purpose of this program is to have a fast file listing, that includes hidden files and also shows the file size and file attributes using colours on screen.
   5  0000              ;File selection will be possible with arrow keys, to select BASIC programs and run them, making it usefull as "run" program for auto-run on HC floppy disks. That's why it tries to be small and fast.
   6  0000              ;Reading the exact file size and file type requires opening up each file, which is slow, so it's not performed. The aproximate file size provided (rounded at 128 bytes) can be used as a hint to guess the file type.
   7  0000              ;Smaller files should be the BASIC loaders (around 256 bytes). SCREEN$ files are 7168 bytes. Larger files are code files usually. Files bigger than 64K are shown with file size in kilobytes.
   8  0000              ;Can display up to 128 files (max supported by HC BASIC file system), grouped in up to 3 pages, 44 files per page. Most disks will have one page listing, quickly showing up all disk info on one screen.
   9  0000              ;System calls are kept at minimum, because are slow. The aproximate file size is determined by processing all file dir entries and summing up the record count instead of calling the system call for file size determination.
  10  0000              ;Free space is determined by summing up file sizes on disk and substracting from maximum possible size (636KB). This allows showing up the ocupied space too, that the ROM doesn't list.
  11  0000              ;Another way to determine space would be to make the system call to get disk the allocation bitmap, but that bitmap is in "phantom RAM" (IF1 paged RAM) so it's more convoluted to read and process it (count set bits).
  12  0000              ;Would be probably faster to process the disk directory by reading the sectors and parsing manually, but that requires more code, and one objective was to have small and clear code. So system calls are used for Find First/Next.
  13  0000              ;Mathematical operations like multiplication and division are performed using bit shifts, since involve numbers that are power of 2. Again this is for having simple and small code.
  14  0000              ;Printing the text uses the BASIC ROM routine, that supports embedded color codes. The IF1 print routine doesn't support that. Direct screen output would be another way, but requires more code. Graphical output (64 columns) was excluded for the same reason.
  15  0000              ;ROM printing routing has an issue with line 21 (out of 0-23), so a trick is used to avoid scrolling: channel 0 is used for the stats printing, then lines 0-21 are printed on channel 2, also poking a variable to prevent scrolling.
  16  0000              ;The disk drive being displayed is the current drive, so the program should work as expected when executed from drive B:, as it doesn't hard code A:. A: is assumed when there's no current drive (like when loading from tape).
  17  0000              ;What was used to develop this program:
  18  0000              ; - SjASMPlus v1.18.2 cross-assembler
  19  0000              ; - Crimson Editor for editing, launching assembler, deploying in emulator
  20  0000              ; - HC 2000 Emulator for Sinclair Spectrum +3 by Rares Atodiresei, for using the Spectaculator emulator with HC-2000 emulation support
  21  0000              ; - Spectaculator emulator, for using the debugger and it's other top quality features
  22  0000              ; - Fuse emulator, version from Alex Badea, with HC-2000 emulation support, for double testing
  23  0000              ; - HCDisk2 by myself, for creating/updating disk images for HC in DSK format.
  24  0000              ;
  25  0000              ;Motivation?
  26  0000              ; - I wanted to refresh my Z80 assembly language
  27  0000              ; - I wanted to create an usefull tool for HC computers, with features that don't exist yet
  28  0000              ; - I wanted to publish the code, in case it's usefull in understanding how HC computers disk system works
  29  0000              ;I realise some people may find it useless, but it's still a good exercise for myself and others.
  30  0000              ;
  31  0000              ;How it works:
  32  0000              ;1. Reads disk catalog and saves a line in a table for each file, with info from directory entry 0: file name, RC count.
  33  0000              ;2. Reads disk catalog again, to read the total record count for each file. This second pass is required because some files may have dir entry 1 show up before dir entry 0.
  34  0000              ;3. Calculates disk space used by files, based on cache table record count, rounding up to 2048 (block size).
  35  0000              ;4. Displays total used space on disk, file count, disk free space, listing page 1/2/3.
  36  0000              ;5. Displays file list and file size in bytes, rounded up at 128 (CPM style). File attributes are shown in color, as noted on screen: red=read only, magenta=system (hidden from CAT), yellow=read only + system.
  37  0000
  38  0000              				DEVICE ZXSPECTRUM48
  39  0000
  40  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main program ;;;;;;;;;;;;;;;;;;;;;;;;;;
  41  0000              	ORG START_ADDR
  42  8000
  43  8000              start:
  44  8000              	;install error handler
  45  8000 2A 3D 5C     	ld		hl, (VAR_ERRSP)
  46  8003 E5           	push	hl
  47  8004 21 80 80     	ld		hl, ErrorHandler
  48  8007 E5           	push	hl
  49  8008 ED 73 3D 5C  	ld		(VAR_ERRSP), sp
  50  800C
  51  800C              	;Init IF1, disk
  52  800C CD 49 80     	call Init
  53  800F
  54  800F              ReadDiskAgain:
  55  800F              	;First read of catalog, to get file list
  56  800F CD E7 83     	call ReadCatalog1
  57  8012              	;Second read of catalog, to get file size
  58  8012 CD 49 84     	call ReadCatalog2
  59  8015              	;Calculate space used by files on disk
  60  8015 CD 5D 81     	call GetDiskUsedSpace
  61  8018              	;Display list of files
  62  8018 CD CB 81     	call DisplayFiles
  63  801B
  64  801B CD F8 81     	call ReadCharLoop
  65  801E
  66  801E              	;restore default error handler
  67  801E E1           	pop		hl
  68  801F E1           	pop		hl
  69  8020 22 3D 5C     	ld		(VAR_ERRSP), hl
  70  8023
  71  8023 C9           	ret
  72  8024
  73  8024              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Char routines ;;;;;;;;;;;;;;;;;;;;;;;;;
  74  8024
  75  8024
  76  8024              ;Return read char in A
  77  8024              ReadChar:
  78  8024 CF           	rst 08
  79  8025 1B           	DEFB 27
  80  8026 C9           	ret
  81  8027
  82  8027              ;Print a string
  83  8027              ;HL=str. addr.
  84  8027              ;B=len
  85  8027              PrintStr:
  86  8027 7E           	ld a, (hl)
  87  8028 E5           	push hl
  88  8029 C5           	push bc
  89  802A D7           		rst $10				;Print using ROM routine, since it supports color output. The IF1 print routine doesn't.
  90  802B C1           	pop bc
  91  802C E1           	pop hl
  92  802D 23           	inc hl
  93  802E 10 F7        	djnz PrintStr
  94  8030 C9           	ret
  95  8031
  96  8031              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  97  8031              SetFastKeys:
  98  8031 21 09 5C     	ld		hl, VAR_REPDEL
  99  8034 11 0F 01     	ld		de, (1 << 8) | 15
 100  8037 73 23 72 2B  	ld		(hl), de
 101  803B C9           	ret
 102  803C
 103  803C              ;Compare string at HL with the one at DE, max length B
 104  803C              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 105  803C              ;OUT: z flag, set = match, reset = mismatch
 106  803C              StrCmp:
 107  803C E5           	push hl
 108  803D D5           	push de
 109  803E              Compare:
 110  803E 1A           		ld a, (de)
 111  803F BE           		cp (hl)
 112  8040 20 04        		jr nz, MisMatch
 113  8042 23           		inc hl
 114  8043 13           		inc de
 115  8044 10 F8        		djnz Compare
 116  8046              MisMatch:
 117  8046 D1           	pop de
 118  8047 E1           	pop hl
 119  8048 C9           	ret
 120  8049
 121  8049              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 122  8049
 123  8049              Init:
 124  8049              ;These 2 calls are not needed when this program is launched from disk, as it will display the current disk.
 125  8049              ;If loaded from tape, it won't work without the 2 calls, since they are needed for DOS initialisation and selecting A: or B:.
 126  8049 CD EE 80     	call InitVars
 127  804C CD 18 81     	call InitDos
 128  804F
 129  804F              	;Select the current drive to work with instead of hardcoding A:.
 130  804F CD 2A 81     	call GetCurrentDrive
 131  8052 FE FF        	cp $FF							;$FF = no current drive, force A:
 132  8054 28 03        	jr  z, CurrentDriveNone
 133  8056 3C           	inc  a							;translate CP/M drive to BASIC drive: 0 -> 1, 1 -> 2
 134  8057 18 02        	jr  SelectDriveInit
 135  8059              CurrentDriveNone:
 136  8059 3E 01        	ld  a, DRIVE_A
 137  805B              SelectDriveInit:
 138  805B CD 1C 81     	call SelectDrive
 139  805E
 140  805E              	;set border and paper to blue
 141  805E 3E 01        	ld  a, CLR_BLUE
 142  8060 D3 FE        	out ($FE), a
 143  8062 3E 0F        	ld a, (CLR_BLUE << 3) | CLR_WHITE
 144  8064 32 48 5C     	ld (VAR_BORDCR), a
 145  8067 32 8D 5C     	ld (VAR_ATTR), a
 146  806A
 147  806A              	;CLS
 148  806A 3E 02        	ld  a, 2
 149  806C CD AF 0D     	call ROM_OPEN_SCR_CLR
 150  806F
 151  806F 3E 00        	ld  a, 0
 152  8071 CD 01 16     	call ROM_OPEN_SCR
 153  8074 21 CC 85     	ld  hl, MsgIntro
 154  8077 06 46        	ld  b, MsgIntroEnd - MsgIntro
 155  8079 CD 27 80     	call PrintStr
 156  807C
 157  807C CD 31 80     	call SetFastKeys
 158  807F
 159  807F C9           	ret
 160  8080
 161  8080
 162  8080              ErrorHandler:
 163  8080 E1           	pop		hl
 164  8081 22 3D 5C     	ld		(VAR_ERRSP), hl
 165  8084
 166  8084 3E 02        	ld		a, 2
 167  8086 CD AF 0D     	call	ROM_OPEN_SCR_CLR
 168  8089
 169  8089 3E 00        	ld		a, 0
 170  808B CD 01 16     	call	ROM_OPEN_SCR
 171  808E
 172  808E 3A 3A 5C     	ld		a, (VAR_ERRNR)
 173  8091 F5           	push	af
 174  8092 6F           	ld		l, a
 175  8093 26 00        	ld		h, 0
 176  8095 11 C7 85     	ld		de, MsgErrCode
 177  8098 CD FF 84     	call	N2ASCII3
 178  809B
 179  809B 21 BD 85     	ld		hl, MsgError
 180  809E 06 0F        	ld		b, MsgErrorEnd - MsgError
 181  80A0 CD 27 80     	call	PrintStr
 182  80A3
 183  80A3 F1           	pop		af
 184  80A4 F5           	push	af
 185  80A5 CD BE 80     	call	GetErrMsg
 186  80A8 21 24 86     	ld		hl, Cache
 187  80AB CD 27 80     	call	PrintStr
 188  80AE
 189  80AE              	;On disk error, select A:, in case drive B: was empty when selected.
 190  80AE F1           	pop		af
 191  80AF FE 10        	cp		$10
 192  80B1 20 05        	jr		nz, DontSelectA
 193  80B3 3E 01        	ld		a, DRIVE_A
 194  80B5 CD 1C 81     	call	SelectDrive
 195  80B8
 196  80B8              DontSelectA:
 197  80B8 CD 24 80     	call	ReadChar
 198  80BB C3 00 80     	jp		start
 199  80BE
 200  80BE
 201  80BE              ;IN DE = message destination
 202  80BE              GetErrMsg:
 203  80BE 3C           	inc		a
 204  80BF 08           	ex		af, af'
 205  80C0
 206  80C0 21 C9 80     	ld		hl, IF1Paged			;page-in IF1
 207  80C3 22 ED 5C     	ld		(VAR_HD11), hl
 208  80C6 CF           	rst		8
 209  80C7 32           	defb	50
 210  80C8 C9           	ret								;return after accesing IF1
 211  80C9
 212  80C9              IF1Paged:
 213  80C9 21 60 02     	ld		hl, ERRMSG
 214  80CC 08           	ex		af, af'
 215  80CD B7           	or		a
 216  80CE 28 0B        	jr		z, SaveMsg
 217  80D0
 218  80D0 06 00        	ld		b, 0
 219  80D2              SearchMsgEnd:
 220  80D2 CB 7E        	bit		7, (hl)
 221  80D4 23           	inc		hl
 222  80D5 28 FB        	jr		z, SearchMsgEnd
 223  80D7
 224  80D7 04           	inc		b
 225  80D8 B8           	cp		b
 226  80D9 20 F7        	jr		nz, SearchMsgEnd
 227  80DB
 228  80DB              SaveMsg:
 229  80DB 11 24 86     	ld		de, Cache
 230  80DE 06 00        	ld		b, 0
 231  80E0              CopyMsg:
 232  80E0 7E           	ld		a, (hl)
 233  80E1 12           	ld		(de), a
 234  80E2 23           	inc		hl
 235  80E3 13           	inc		de
 236  80E4 04           	inc		b
 237  80E5 CB 7F        	bit		7, a
 238  80E7 28 F7        	jr		z, CopyMsg
 239  80E9 EB           	ex		de, hl
 240  80EA 2B           	dec		hl
 241  80EB CB BE        	res		7, (hl)
 242  80ED C9           	ret
 243  80EE
 244  80EE
 245  80EE
 246  80EE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Disk routines ;;;;;;;;;;;;;;;;;;;;;;;;;
 247  80EE
 248  80EE              ;Insert IF1 variables
 249  80EE              InitVars:
 250  80EE CF           	rst 08
 251  80EF 31           	DEFB 49
 252  80F0 C9           	ret
 253  80F1
 254  80F1              ;Create a disk channel for BDOS access (does not open the file)
 255  80F1              ;IN: HL=name addr, B=drive, C=name len
 256  80F1              ;OUT: IX=FCB
 257  80F1              CreateChannel:
 258  80F1 22 DC 5C     	ld (VAR_FSTR1), hl
 259  80F4 26 00        	ld h,0
 260  80F6 68           	ld l,b
 261  80F7 22 D6 5C     	ld (VAR_DSTR1), hl
 262  80FA 69           	ld l,c
 263  80FB 22 DA 5C     	ld (VAR_NSTR1), hl
 264  80FE CF           	rst 08
 265  80FF 37           	DEFB 55
 266  8100 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
 267  8103 DD 09        	add ix, bc
 268  8105 C9           	ret
 269  8106
 270  8106
 271  8106              ;Destroy a BDOS channel
 272  8106              ;IN: IX=FCB
 273  8106              DestroyChannel:
 274  8106 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
 275  8109 DD 09        	add ix, bc
 276  810B CF           	rst 08
 277  810C 38           	DEFB 56
 278  810D C9           	ret
 279  810E
 280  810E
 281  810E              ;Generic BDOS call
 282  810E              ;IX=arg, A=function
 283  810E              BDOS:
 284  810E DD 22 ED 5C  	ld (VAR_HD11), ix
 285  8112 32 EF 5C     	ld (VAR_COPIES), a
 286  8115 CF           	rst 08
 287  8116 39           	DEFB 57
 288  8117 C9           	ret
 289  8118
 290  8118              InitDos:
 291  8118 3E 00        	ld	a, 0
 292  811A 18 F2        	jr	BDOS
 293  811C
 294  811C              ;IN A=selected drive
 295  811C              SelectDrive:
 296  811C 32 1D 86     	ld  (DRIVE_SELECTED), a
 297  811F 3D           	dec a		;CPM drive is 0=A or 1=B. For BASIC is 1=A, 2=B, 0=current drive. So we must convert it for the CPM call, otherwise the BDOS function crashes.
 298  8120 DD 26 00     	ld  ixh, 0
 299  8123 DD 6F        	ld	ixl, a	;0=A, 1=B
 300  8125 3E 01        	ld	a, 1	;1=Select disk
 301  8127 18 E5        	jr	BDOS
 302  8129 C9           	ret
 303  812A
 304  812A              ;Returns current disk in A: 0=A:, 1=B:, $FF=no current drive
 305  812A              GetCurrentDrive:
 306  812A 3E 0C        	ld a, 12
 307  812C 18 E0        	jr BDOS
 308  812E
 309  812E              ;FindFirst
 310  812E              ;IX=fcb
 311  812E              FindFirst:
 312  812E 3E 04        	ld a, 4
 313  8130 18 DC        	jr BDOS
 314  8132
 315  8132
 316  8132              ;FindNext
 317  8132              ;IX=fcb
 318  8132              FindNext:
 319  8132 3E 05        	ld a, 5
 320  8134 18 D8        	jr BDOS
 321  8136
 322  8136
 323  8136              ;Set DMA address for BDOS into the already alocated (and unused) 256 bytes channel buffer
 324  8136              ;IX=fcb
 325  8136              SetDMA:
 326  8136 01 26 00     	ld bc, CH_DMA		;offset into alocated data area of the channel (256 bytes)
 327  8139 DD E5        	push ix
 328  813B DD 09        		add ix, bc
 329  813D 3E 0D        		ld a, 13
 330  813F CD 0E 81     		call BDOS
 331  8142 DD E1        	pop ix
 332  8144 C9           	ret
 333  8145
 334  8145              ;Load a program from disk
 335  8145              ;IN: HL = file name addr
 336  8145              LoadProgram:
 337  8145 22 DC 5C     	LD   (VAR_FSTR1), HL
 338  8148 26 00        	LD   H, 0
 339  814A 2E 0B        	LD   L, NAMELEN
 340  814C 22 DA 5C     	LD   (VAR_NSTR1), HL
 341  814F              	;LD	 A, (DRIVE_SELECTED)
 342  814F 2E 00        	LD   L, DRIVE_CURRENT			;load from current drive
 343  8151 22 D6 5C     	LD   (VAR_DSTR1), HL
 344  8154 21 41 0A     	LD   HL, LOAD_ADDR
 345  8157 22 ED 5C     	LD   (VAR_HD11), HL
 346  815A CF           	RST  8
 347  815B 32           	DEFB 50
 348  815C C9           	ret								;ret to BASIC in case the program exits
 349  815D              	;Control is now given to the program being executed.
 350  815D
 351  815D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 352  815D
 353  815D              ;Sum up file size on disk for all files. It's easier than parsing the block bitmap in phantom RAM.
 354  815D              GetDiskUsedSpace:
 355  815D 21 24 86     	ld		hl, Cache
 356  8160 3A 1E 86     	ld		a, (FileCnt)
 357  8163 47           	ld		b, a
 358  8164
 359  8164              FileSizeLoop:
 360  8164 C5           	push	bc
 361  8165 01 0B 00     		ld		bc, NAMELEN
 362  8168 09           		add		hl, bc
 363  8169
 364  8169 4E           		ld		c, (hl)
 365  816A 23           		inc		hl
 366  816B 46           		ld		b, (hl)
 367  816C 23           		inc		hl
 368  816D
 369  816D E5           		push	hl
 370  816E C5           			push	bc
 371  816F E1           			pop		hl
 372  8170 CD 80 81     			call	GetFileSizeOnDiskKB
 373  8173
 374  8173 ED 4B 1F 86  			ld		bc, (UsedKB)
 375  8177 09           			add		hl, bc
 376  8178 22 1F 86     			ld		(UsedKB), hl
 377  817B E1           		pop		hl
 378  817C C1           	pop		bc
 379  817D 10 E5        	djnz	FileSizeLoop
 380  817F C9           	ret
 381  8180
 382  8180
 383  8180              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 384  8180
 385  8180              ;IN HL=RC count
 386  8180              ;OUT HL = File size on disk in KB
 387  8180              ;(RC count * 128) / 2048 = RC count * 16 = block count. Block count * 2 = KB on disk
 388  8180              GetFileSizeOnDiskKB:
 389  8180 AF           	xor a
 390  8181
 391  8181              	;/2
 392  8181 CB 3C        	srl	h
 393  8183 CB 1D        	rr	l
 394  8185 17           	rla
 395  8186              	;/4
 396  8186 CB 3C        	srl	h
 397  8188 CB 1D        	rr	l
 398  818A 17           	rla
 399  818B              	;/8
 400  818B CB 3C        	srl	h
 401  818D CB 1D        	rr	l
 402  818F 17           	rla
 403  8190              	;/16
 404  8190 CB 3C        	srl	h
 405  8192 CB 1D        	rr	l
 406  8194 17           	rla
 407  8195
 408  8195 B7           	or  a
 409  8196 28 01        	jr  z, NoPartialAU
 410  8198 23           	inc	hl
 411  8199              NoPartialAU:
 412  8199
 413  8199              	;block count * 2 = KB
 414  8199 CB 25        	sla	l
 415  819B CB 14        	rl	h
 416  819D C9           	ret
 417  819E
 418  819E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 419  819E
 420  819E              ;IN HL = RC count
 421  819E              DisplayFileLength:
 422  819E              	;check if RC >= $200 RC, to display size in KB then, as it doesn't fit in 16 bits.
 423  819E 3E 02        	ld  a, 2
 424  81A0 94           	sub h
 425  81A1 38 16        	jr  c, BigFile
 426  81A3
 427  81A3              	;RC * 128 = size in bytes rounded at 128.
 428  81A3              	;h << 7
 429  81A3 CB 0C        	rrc h
 430  81A5              	;l >> 1
 431  81A5 CB 3D        	srl l
 432  81A7              	;save carry	in H
 433  81A7 CB 1C        	rr h
 434  81A9              	;save L
 435  81A9 7D           	ld  a, l
 436  81AA 2E 00        	ld  l, 0
 437  81AC              	;save bit 7 of L
 438  81AC CB 14        	rl h
 439  81AE CB 1D        	rr l
 440  81B0              	;save H + 7 bits of L
 441  81B0 B4           	or  h
 442  81B1 67           	ld  h, a
 443  81B2
 444  81B2 11 B8 85     	ld  de, FileLen
 445  81B5 CD 09 85     	call N2ASCII5
 446  81B8
 447  81B8 C9           	ret
 448  81B9
 449  81B9              BigFile:
 450  81B9 CD 80 81     	call GetFileSizeOnDiskKB
 451  81BC
 452  81BC 11 B8 85     	ld  de, FileLen
 453  81BF CD FF 84     	call N2ASCII3
 454  81C2 13           	inc  de
 455  81C3 3E 4B        	ld  a, 'K'
 456  81C5 12           	ld  (de), a
 457  81C6 13           	inc de
 458  81C7 3E 42        	ld  a, 'B'
 459  81C9 12           	ld  (de), a
 460  81CA
 461  81CA C9           	ret
 462  81CB
 463  81CB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 464  81CB              DisplayFiles:
 465  81CB 3E 31        	ld  a, '1'
 466  81CD 32 52 85     	ld  (ScrPageMsg), a
 467  81D0 32 54 85     	ld  (ScrPageMsgMax), a
 468  81D3
 469  81D3 3A 1E 86     	ld a, (FileCnt)
 470  81D6 B7           	or a
 471  81D7 20 07        	jr  nz, NonEmptyDisk
 472  81D9 CD BA 84     	call DisplayStats
 473  81DC CD 24 80     	call ReadChar
 474  81DF C9           	ret
 475  81E0
 476  81E0              NonEmptyDisk:
 477  81E0              	;detemine how many file list pages we have (1-3)
 478  81E0 21 54 85     	ld hl, ScrPageMsgMax
 479  81E3              ScreenCntLoop:
 480  81E3 D6 2C        	sub MAX_FILES_SCR
 481  81E5 34           	inc (hl)
 482  81E6 30 FB        	jr  nc, ScreenCntLoop
 483  81E8 35           	dec (hl)
 484  81E9
 485  81E9              DisplayFilesLoop:
 486  81E9 AF           	xor a
 487  81EA 32 A3 85     	ld (TabChar), a
 488  81ED
 489  81ED CD E5 82     	call GetFileListForScreen
 490  81F0 78           	ld  a, b
 491  81F1 32 23 86     	ld  (FileCntScr), a
 492  81F4 CD 42 83     	call DisplayOneScreen
 493  81F7 C9           	ret
 494  81F8
 495  81F8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 496  81F8
 497  81F8              ReadCharLoop:
 498  81F8 CD 24 80     	call ReadChar
 499  81FB FE 07        	cp  KEY_ESC
 500  81FD C8           	ret z
 501  81FE
 502  81FE FE 31        	cp  '1'
 503  8200 28 46        	jr  z, SelectDriveA
 504  8202 FE 32        	cp  '2'
 505  8204 28 46        	jr  z, SelectDriveB
 506  8206
 507  8206 FE 0A        	cp KEY_DOWN
 508  8208 20 05        	jr nz, CheckKeyUp
 509  820A CD 8C 82     	call CursorDown
 510  820D 18 E9        	jr ReadCharLoop
 511  820F
 512  820F              CheckKeyUp:
 513  820F FE 0B        	cp KEY_UP
 514  8211 20 05        	jr nz, CheckKeyRight
 515  8213 CD 94 82     	call CursorUp
 516  8216 18 E0        	jr ReadCharLoop
 517  8218
 518  8218              CheckKeyRight:
 519  8218 FE 09        	cp KEY_RIGHT
 520  821A 20 05        	jr nz, CheckKeyLeft
 521  821C CD 90 82     	call CursorRight
 522  821F 18 D7        	jr ReadCharLoop
 523  8221
 524  8221              CheckKeyLeft:
 525  8221 FE 08        	cp KEY_LEFT
 526  8223 20 05        	jr  nz, CheckEnter
 527  8225 CD 98 82     	call CursorLeft
 528  8228 18 CE        	jr  ReadCharLoop
 529  822A
 530  822A              CheckEnter:
 531  822A FE 0D        	cp KEY_ENTER
 532  822C 20 CA        	jr nz, ReadCharLoop
 533  822E
 534  822E              	;Read current screen number.
 535  822E 3A 52 85     	ld a, (ScrPageMsg)
 536  8231 D6 31        	sub '1'
 537  8233 B7           	or  a
 538  8234 28 06        	jr  z, FirstPageIndex
 539  8236 47           	ld  b, a
 540  8237 AF           	xor a
 541  8238              PageAddLoop:
 542  8238 C6 2C        	add MAX_FILES_SCR
 543  823A 10 FC        	djnz PageAddLoop
 544  823C              FirstPageIndex:
 545  823C 21 22 86     	ld hl, SelFileIdxScr
 546  823F 86           	add (hl)
 547  8240 47           	ld  b, a
 548  8241 CD 35 83     	call FindCacheByIndex
 549  8244
 550  8244 D1           	pop de							;restore stack for this call
 551  8245              	;restore default error handler, if a game throws an error, the error handler might be overwritten already.
 552  8245 ~            	/*
 553  8245 ~            	ex  de, hl
 554  8245 ~            	pop		hl
 555  8245 ~            	pop		hl
 556  8245 ~            	ld		(VAR_ERRSP), hl
 557  8245 ~            	ex  de, hl
 558  8245 ~            	*/
 559  8245
 560  8245              	;Control is now given to the program being executed.
 561  8245 C3 45 81     	jp LoadProgram
 562  8248
 563  8248              SelectDriveA:
 564  8248 3E 01        	ld  a, DRIVE_A
 565  824A 18 02        	jr  SwitchDrive
 566  824C              SelectDriveB:
 567  824C 3E 02        	ld  a, DRIVE_B
 568  824E              SwitchDrive:
 569  824E CD 1C 81     	call SelectDrive
 570  8251 E1           	pop  hl							;restore stack for this call
 571  8252 C3 0F 80     	jp   ReadDiskAgain
 572  8255
 573  8255              NextScr:
 574  8255 21 52 85     	ld hl, ScrPageMsg
 575  8258 3A 54 85     	ld a, (ScrPageMsgMax)
 576  825B BE           	cp (hl)
 577  825C C8           	ret z
 578  825D 34           	inc (hl)
 579  825E C3 E9 81     	jp DisplayFilesLoop
 580  8261
 581  8261              PrevScr:
 582  8261 21 52 85     	ld hl, ScrPageMsg
 583  8264 3E 31        	ld  a, '1'
 584  8266 BE           	cp (hl)
 585  8267 C8           	ret z
 586  8268 35           	dec (hl)
 587  8269 C3 E9 81     	jp DisplayFilesLoop
 588  826C
 589  826C
 590  826C              CursorDownOrRight:
 591  826C 3A 23 86     	ld a, (FileCntScr)
 592  826F 47           	ld b, a
 593  8270 3A 22 86     	ld a, (SelFileIdxScr)
 594  8273 81           	add c
 595  8274 B8           	cp b
 596  8275 38 06        	jr c, CursorDownValidSelection
 597  8277
 598  8277              	;Cursor moved outside screen, check if we need to move to next screen.
 599  8277 3E 2C        	ld  a, MAX_FILES_SCR
 600  8279 B8           	cp  b
 601  827A 28 D9        	jr  z, NextScr
 602  827C C9           	ret
 603  827D
 604  827D              CursorDownValidSelection:
 605  827D              	;The selection is within the file list, draw it.
 606  827D 32 22 86     	ld (SelFileIdxScr), a
 607  8280 C5           	push bc
 608  8281 F5           	push af
 609  8282 CD B1 82     		call DrawCursor
 610  8285 F1           	pop af
 611  8286 C1           	pop bc
 612  8287 91           	sub c
 613  8288 CD B1 82     	call DrawCursor
 614  828B C9           	ret
 615  828C
 616  828C
 617  828C              CursorDown:
 618  828C 0E 02        	ld  c, 2
 619  828E 18 DC        	jr  CursorDownOrRight
 620  8290
 621  8290              CursorRight:
 622  8290 0E 01        	ld  c, 1
 623  8292 18 D8        	jr  CursorDownOrRight
 624  8294
 625  8294              CursorUp:
 626  8294 0E 02        	ld c, 2
 627  8296 18 04        	jr CursorUpOrLeft
 628  8298
 629  8298              CursorLeft:
 630  8298 0E 01        	ld c, 1
 631  829A 18 00        	jr CursorUpOrLeft
 632  829C
 633  829C              CursorUpOrLeft:
 634  829C 3A 22 86     	ld a, (SelFileIdxScr)
 635  829F B9           	cp c
 636  82A0 38 BF        	jr c, PrevScr
 637  82A2
 638  82A2 C5           	push bc
 639  82A3 F5           	push af
 640  82A4 CD B1 82     		call DrawCursor
 641  82A7 F1           	pop af
 642  82A8 C1           	pop bc
 643  82A9 91           	sub c
 644  82AA 32 22 86     	ld (SelFileIdxScr), a
 645  82AD CD B1 82     	call DrawCursor
 646  82B0 C9           	ret
 647  82B1
 648  82B1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 649  82B1              ;IN A = file index to highlite (0 - 43)
 650  82B1              DrawCursor:
 651  82B1 4F           	ld c, a
 652  82B2 06 00        	ld b, 0
 653  82B4              	;*16
 654  82B4 CB 21        	sla c
 655  82B6 CB 10        	rl b
 656  82B8 CB 21        	sla c
 657  82BA CB 10        	rl b
 658  82BC CB 21        	sla c
 659  82BE CB 10        	rl b
 660  82C0 CB 21        	sla c
 661  82C2 CB 10        	rl b
 662  82C4
 663  82C4 21 00 58     	ld hl, SCR_ATTR_ADDR
 664  82C7 09           	add hl, bc
 665  82C8
 666  82C8 06 10        	ld b, SCR_COLUMNS/2
 667  82CA              DrawCursorLoop:
 668  82CA 7E           	ld a, (hl)
 669  82CB              	;draw inverse
 670  82CB E6 07        	and %111
 671  82CD 4F           	ld  c, a
 672  82CE CB 11        	rl c
 673  82D0 CB 11        	rl c
 674  82D2 CB 11        	rl c
 675  82D4 7E           	ld a, (hl)
 676  82D5 E6 38        	and %111000
 677  82D7 1F           	rra
 678  82D8 1F           	rra
 679  82D9 1F           	rra
 680  82DA B1           	or c
 681  82DB 4F           	ld  c, a
 682  82DC 7E           	ld a, (hl)
 683  82DD              	;keep bright, flash
 684  82DD E6 C0        	and %11000000
 685  82DF B1           	or c
 686  82E0 77           	ld (hl), a
 687  82E1 23           	inc hl
 688  82E2 10 E6        	djnz DrawCursorLoop
 689  82E4
 690  82E4 C9           	ret
 691  82E5
 692  82E5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 693  82E5              ;Determine the cache line to start with (in HL) and how many files to show (in B)
 694  82E5              ;page1 = files 1-44, page2 = files 45 - 88, page3 = 89 - 128
 695  82E5              GetFileListForScreen:
 696  82E5 3A 1E 86     	ld  a, (FileCnt)
 697  82E8 4F           	ld  c, a
 698  82E9 3A 52 85     	ld  a, (ScrPageMsg)
 699  82EC 5F           	ld  e, a
 700  82ED 3A 54 85     	ld a, (ScrPageMsgMax)
 701  82F0 FE 31        	cp '1'
 702  82F2 28 08        	jr  z, OneScreenMax
 703  82F4 FE 32        	cp '2'
 704  82F6 28 08        	jr  z, TwoScreensMax
 705  82F8 FE 33        	cp '3'
 706  82FA 28 17        	jr  z, ThreeScreensMax
 707  82FC
 708  82FC              ;determine file list offset for file list on screen and file count for
 709  82FC              OneScreenMax:
 710  82FC 06 00        	ld  b, 0
 711  82FE 18 30        	jr 	FindCacheLine
 712  8300              TwoScreensMax:
 713  8300 7B           	ld  a, e
 714  8301 FE 32        	cp  '2'
 715  8303 28 06        	jr  z, Page2of2
 716  8305              Page1of2:
 717  8305 06 00        	ld  b, 0					;start from first file for page 1
 718  8307 0E 2C        	ld  c, MAX_FILES_SCR		;display full screen of files, more to come
 719  8309 18 25        	jr  FindCacheLine
 720  830B              Page2of2:
 721  830B 06 2C        	ld  b, MAX_FILES_SCR		;skip first page of files for page 2
 722  830D 79           	ld  a, c
 723  830E D6 2C        	sub MAX_FILES_SCR
 724  8310 4F           	ld  c, a					;get rest of files for page 2
 725  8311 18 1D        	jr 	FindCacheLine
 726  8313              ThreeScreensMax:
 727  8313 7B           	ld  a, e
 728  8314 FE 33        	cp  '3'
 729  8316 28 10        	jr  z, Page3of3
 730  8318 FE 32        	cp  '2'
 731  831A 28 06        	jr  z, Page2of3
 732  831C              Page1of3:
 733  831C 06 00        	ld  b, 0					;start from first file for page 1
 734  831E 0E 2C        	ld  c, MAX_FILES_SCR		;display full page of files, more to come
 735  8320 18 0E        	jr  FindCacheLine
 736  8322              Page2of3:
 737  8322 06 2C        	ld  b, MAX_FILES_SCR		;skip first page of files for page 2
 738  8324 0E 2C        	ld  c, MAX_FILES_SCR		;display full page of files, more to come
 739  8326 18 08        	jr  FindCacheLine
 740  8328              Page3of3:
 741  8328 06 58        	ld  b, 2*MAX_FILES_SCR		;skip first 2 pages of files for page 3
 742  832A 79           	ld  a, c
 743  832B D6 2C        	sub MAX_FILES_SCR
 744  832D D6 2C        	sub MAX_FILES_SCR
 745  832F 4F           	ld  c, a					;get rest of files for page 2
 746  8330
 747  8330              FindCacheLine:
 748  8330 CD 35 83     	call FindCacheByIndex
 749  8333
 750  8333 41           	ld  b, c
 751  8334 C9           	ret
 752  8335
 753  8335              ;IN B=cache index to put in HL
 754  8335              FindCacheByIndex:
 755  8335 11 0D 00     	ld	de, CACHE_LN_SZ
 756  8338 21 24 86     	ld 	hl, Cache
 757  833B 78           	ld  a, b
 758  833C B7           	or  a
 759  833D C8           	ret z
 760  833E              FindCacheLineLoop:
 761  833E 19           	add	hl, de
 762  833F 10 FD        	djnz FindCacheLineLoop
 763  8341 C9           	ret
 764  8342
 765  8342              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 766  8342              ;Shows file lists for one screen, with cache from HL and file count from B
 767  8342              DisplayOneScreen:
 768  8342 C5           	push	bc
 769  8343 E5           	push	hl
 770  8344 3E 02        		ld  a, 2
 771  8346 CD AF 0D     		call ROM_OPEN_SCR_CLR
 772  8349              		;Display occupied space, file number, free space, page
 773  8349 CD BA 84     		call DisplayStats
 774  834C E1           	pop		hl
 775  834D C1           	pop		bc
 776  834E
 777  834E C5           	push 	bc
 778  834F E5           	push 	hl
 779  8350              		;prevent scroll up, to be able to display on row 21
 780  8350 AF           		xor a
 781  8351 32 6B 5C     		ld  (VAR_SCROLL2), a
 782  8354
 783  8354 32 A8 85     		ld (DisplayedBright), a
 784  8357
 785  8357 CD 69 83     		call DisplayFilesInfo
 786  835A
 787  835A              		;restore scroll, to prevent crash
 788  835A 21 6B 5C     		ld  hl, VAR_SCROLL2
 789  835D 36 02        		ld  (hl), 2
 790  835F
 791  835F AF           		xor a
 792  8360 32 22 86     		ld (SelFileIdxScr), a
 793  8363 CD B1 82     		call DrawCursor
 794  8366 E1           	pop	 hl
 795  8367 C1           	pop  bc
 796  8368
 797  8368 C9           	ret
 798  8369
 799  8369
 800  8369              ;Displays info for each file. A table already contains lines of: FileName, RC count
 801  8369              ;IN HL=file cache line, B=file count
 802  8369              DisplayFilesInfo:
 803  8369 E5           	push hl
 804  836A 3E 02        	ld  a, 2
 805  836C CD 01 16     	call ROM_OPEN_SCR
 806  836F E1           	pop	hl
 807  8370
 808  8370              	;return if 0 files on disk
 809  8370 78           	ld a, b
 810  8371 B7           	or a
 811  8372 C8           	ret z
 812  8373
 813  8373              	;Use C as file index, for alternating brightness.
 814  8373 0E 01        	ld  c, 1
 815  8375              DisplayLoop:
 816  8375 C5           	push bc
 817  8376 E5           	push hl
 818  8377              		;set file name for display
 819  8377 11 AB 85     		ld   de, FileName
 820  837A D5           		push de
 821  837B 01 0B 00     			ld	 bc, NAMELEN
 822  837E ED B0        			ldir
 823  8380
 824  8380 4E 23 46 2B  			ld  bc, (hl)
 825  8384 69           			ld  l, c
 826  8385 60           			ld  h, b
 827  8386 CD 9E 81     			call DisplayFileLength
 828  8389 DD E1        		pop  ix
 829  838B
 830  838B CD C1 83     		call CheckAttributes
 831  838E
 832  838E              		;fix invalid chars in name
 833  838E 06 0B        		ld  b, NAMELEN
 834  8390 21 AB 85     		ld  hl, FileName
 835  8393              FileNameCopy:
 836  8393 7E           		ld  a, (hl)
 837  8394 E6 7F        		and $7F									;clear bit 7; LOAD accepts bit 7 set or not set (char SCREEN$ or *)
 838  8396 FE 20        		cp  ' '
 839  8398 30 02        		jr  nc, GoodChar
 840  839A 3E 3F        		ld  a, '?'
 841  839C              GoodChar:
 842  839C 77           		ld  (hl), a
 843  839D 23           		inc  hl
 844  839E 10 F3        		djnz FileNameCopy
 845  83A0
 846  83A0              		;display line
 847  83A0 21 A2 85     		ld hl, DisplayedLine
 848  83A3 06 1B        		ld b, DisplayedLineEnd-DisplayedLine	;how many chars on one line
 849  83A5 CD 27 80     		call PrintStr
 850  83A8
 851  83A8              		;set tab every 2 entries
 852  83A8 3A A3 85     		ld a, (TabChar)
 853  83AB EE 10        		xor SCR_COLUMNS/2
 854  83AD 32 A3 85     		ld (TabChar), a
 855  83B0 E1           	pop hl
 856  83B1 01 0D 00     	ld  bc, CACHE_LN_SZ
 857  83B4 09           	add hl, bc
 858  83B5 C1           	pop bc
 859  83B6
 860  83B6              	;set alternating bright every 2 entries
 861  83B6 79           	ld  a, c
 862  83B7 E6 02        	and 2
 863  83B9 1F           	rra
 864  83BA 32 A8 85     	ld (DisplayedBright), a
 865  83BD 0C           	inc c
 866  83BE 10 B5        	djnz DisplayLoop
 867  83C0
 868  83C0 C9           	ret
 869  83C1
 870  83C1
 871  83C1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 872  83C1
 873  83C1              ;Checks the attributes and reset the bits, saving result as color attribute
 874  83C1              ;IX=file name
 875  83C1              CheckAttributes:
 876  83C1 3E 05        	ld  a, CLR_NAME
 877  83C3 DD CB 08 7E  	bit 7, (ix+ATTR_RO_POS)
 878  83C7 28 06        	jr  z, NotRO
 879  83C9 DD CB 08 BE  	res 7, (ix+ATTR_RO_POS)
 880  83CD 3E 02        	ld  a, CLR_RO
 881  83CF              NotRO:
 882  83CF DD CB 09 7E  	bit 7, (ix+ATTR_SYS_POS)
 883  83D3 28 0E        	jr  z, NotSys
 884  83D5 DD CB 09 BE  	res 7, (ix+ATTR_SYS_POS)
 885  83D9 FE 02        	cp  CLR_RO
 886  83DB 28 04        	jr  z, BothAttr
 887  83DD 3E 03        	ld  a, CLR_SYS
 888  83DF 18 02        	jr  NotSys
 889  83E1              BothAttr:
 890  83E1 3E 04        	ld  a, CLR_RO_SYS
 891  83E3              NotSys:
 892  83E3 32 AA 85     	ld (FileNameClr), a
 893  83E6 C9           	ret
 894  83E7
 895  83E7
 896  83E7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 897  83E7
 898  83E7              ;Read directory and create a table (name - 11B, RC count - 2B)
 899  83E7              ReadCatalog1:
 900  83E7 AF           	xor a
 901  83E8 6F           	ld l, a
 902  83E9 67           	ld h, a
 903  83EA 22 1F 86     	ld (UsedKB), hl					;reset used blocks
 904  83ED 32 1E 86     	ld (FileCnt), a					;reset file counter
 905  83F0 3E 80        	ld  a, MAX_DIR_ENT
 906  83F2 32 21 86     	ld (FreeCatalog), a
 907  83F5
 908  83F5 21 12 86     	ld hl, FileMask
 909  83F8 3A 1D 86     	ld a, (DRIVE_SELECTED)
 910  83FB 47           	ld b, a							;drive
 911  83FC 0E 0B        	ld c, NAMELEN					;name len
 912  83FE CD F1 80     	call CreateChannel
 913  8401 CD 36 81     	call SetDMA
 914  8404
 915  8404 3E 00        	ld	a, 0						;request first extension
 916  8406 DD 77 0C     	ld (ix + FCB_EX_IDX), a
 917  8409
 918  8409 CD 2E 81     	call FindFirst
 919  840C 11 24 86     	ld de, Cache
 920  840F
 921  840F              CatNext:
 922  840F 3C           	inc a
 923  8410 28 33        	jr z, CatEnd			;return if A=FFh
 924  8412 3D           	dec a
 925  8413
 926  8413 DD E5        	push ix
 927  8415 01 26 00     		ld bc, CH_DMA
 928  8418 DD 09        		add ix, bc
 929  841A
 930  841A              		;A is the index for the 32 byte dir. entry in DMA buffer
 931  841A 17           		rla
 932  841B 17           		rla
 933  841C 17           		rla
 934  841D 17           		rla
 935  841E 17           		rla
 936  841F 06 00        		ld b, 0
 937  8421 4F           		ld c, a
 938  8422 DD 09        		add ix, bc						;hl=file name -1=FCB
 939  8424
 940  8424              		;put name in cache
 941  8424 DD E5        		push ix
 942  8426 E1           		pop hl
 943  8427 23           		inc hl						;HL = file name
 944  8428 01 0B 00     		ld  bc, NAMELEN
 945  842B ED B0        		ldir
 946  842D
 947  842D              		;skip EX, S1, S2
 948  842D 23           		inc hl
 949  842E 23           		inc hl
 950  842F 23           		inc hl
 951  8430              		;save RC count for first extension
 952  8430 ED A0        		ldi
 953  8432 AF           		xor a
 954  8433 12           		ld (de), a
 955  8434 13           		inc de
 956  8435 DD E1        	pop  ix
 957  8437
 958  8437 3A 1E 86     	ld a, (FileCnt)
 959  843A 3C           	inc a
 960  843B 32 1E 86     	ld (FileCnt), a
 961  843E
 962  843E              	;find next file
 963  843E D5           	push de
 964  843F CD 32 81     		call FindNext
 965  8442 D1           	pop de
 966  8443
 967  8443 18 CA        	jr CatNext
 968  8445              CatEnd:
 969  8445
 970  8445 CD 06 81     	call DestroyChannel
 971  8448 C9           	ret
 972  8449
 973  8449
 974  8449              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 975  8449              ;Will ignore extensions with index 0, will add up RC count for subsequent extensions.
 976  8449              ReadCatalog2:
 977  8449 21 12 86     	ld hl, FileMask
 978  844C 3A 1D 86     	ld a, (DRIVE_SELECTED)
 979  844F 47           	ld b, a							;drive
 980  8450 0E 0B        	ld c, NAMELEN					;name len
 981  8452 CD F1 80     	call CreateChannel
 982  8455 CD 36 81     	call SetDMA
 983  8458
 984  8458 3E 3F        	ld	a, '?'						;request all extensions
 985  845A DD 77 0C     	ld (ix + FCB_EX_IDX), a
 986  845D
 987  845D CD 2E 81     	call FindFirst
 988  8460
 989  8460              CatNext2:
 990  8460 3C           	inc a
 991  8461 28 3E        	jr z, CatEnd2			;return if A=FFh
 992  8463 3D           	dec a
 993  8464
 994  8464 21 21 86     	ld hl, FreeCatalog
 995  8467 35           	dec (hl)
 996  8468
 997  8468 DD E5        	push ix
 998  846A 01 26 00     		ld bc, CH_DMA
 999  846D DD 09        		add ix, bc
1000  846F
1001  846F              		;A is the index for the 32 byte dir. entry in DMA buffer
1002  846F 17           		rla
1003  8470 17           		rla
1004  8471 17           		rla
1005  8472 17           		rla
1006  8473 17           		rla
1007  8474 06 00        		ld b, 0
1008  8476 4F           		ld c, a
1009  8477 DD 09        		add ix, bc						;hl=file name -1=FCB
1010  8479
1011  8479              		;now ignore entries with index 0, as these are already processed
1012  8479 DD 7E 0C     		ld  a, (ix + FCB_EX_IDX)
1013  847C B7           		or  a
1014  847D 28 1B        		jr  z, Cat2Index0
1015  847F
1016  847F              		;find cache for this file
1017  847F DD E5        		push ix
1018  8481 E1           		pop  hl
1019  8482 23           		inc  hl
1020  8483 CD A5 84     		call FindCacheByName
1021  8486
1022  8486 EB           		ex  de, hl
1023  8487 01 0B 00     		ld  bc, NAMELEN
1024  848A 09           		add hl, bc
1025  848B
1026  848B              		;add RC count in cache
1027  848B 4E           		ld  c, (hl)
1028  848C 23           		inc hl
1029  848D 46           		ld  b, (hl)
1030  848E 2B           		dec hl
1031  848F EB           		ex  de, hl
1032  8490 DD 6E 0F     		ld  l, (ix + FCB_RC)
1033  8493 26 00        		ld  h, 0
1034  8495 09           		add hl, bc
1035  8496 EB           		ex  de, hl
1036  8497 73           		ld  (hl), e
1037  8498 23           		inc hl
1038  8499 72           		ld  (hl), d
1039  849A              Cat2Index0:
1040  849A DD E1        	pop  ix
1041  849C
1042  849C CD 32 81     	call FindNext
1043  849F
1044  849F 18 BF        	jr CatNext2
1045  84A1              CatEnd2:
1046  84A1
1047  84A1 CD 06 81     	call DestroyChannel
1048  84A4 C9           	ret
1049  84A5
1050  84A5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1051  84A5              ;IN HL = name address
1052  84A5              ;OUT DE = file row in cache
1053  84A5              FindCacheByName:
1054  84A5 11 24 86     	ld  de, Cache
1055  84A8
1056  84A8              FindCacheLoop:
1057  84A8 E5           	push hl
1058  84A9 D5           	push de
1059  84AA 06 0B        		ld  b, NAMELEN
1060  84AC CD 3C 80     		call StrCmp
1061  84AF D1           	pop  de
1062  84B0 E1           	pop  hl
1063  84B1 C8           	ret z
1064  84B2
1065  84B2              	;skip RC count in cache
1066  84B2 EB           	ex  de, hl
1067  84B3 01 0D 00     	ld  bc, CACHE_LN_SZ
1068  84B6 09           	add hl, bc
1069  84B7 EB           	ex  de, hl
1070  84B8 18 EE        	jr  FindCacheLoop
1071  84BA
1072  84BA
1073  84BA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1074  84BA
1075  84BA              ;Displays free space
1076  84BA              DisplayStats:
1077  84BA 2A 1F 86     	ld   hl, (UsedKB)
1078  84BD E5           	push hl
1079  84BE 11 83 85     		ld de, UsedSpaceAsc
1080  84C1 CD FF 84     		call N2ASCII3
1081  84C4 C1           	pop  bc
1082  84C5
1083  84C5 21 7C 02     	ld  hl, (MAX_FREE_AU_CNT * AU_SZ)/1024
1084  84C8 B7 ED 42     	sub hl, bc
1085  84CB 11 92 85     	ld de, FreeSpaceAsc
1086  84CE CD FF 84     	call N2ASCII3
1087  84D1
1088  84D1 3A 1E 86     	ld a, (FileCnt)
1089  84D4 26 00        	ld h, 0
1090  84D6 6F           	ld l, a
1091  84D7 11 88 85     	ld de, FileCntMsg
1092  84DA CD FF 84     	call N2ASCII3
1093  84DD
1094  84DD 3A 1D 86     	ld  a, (DRIVE_SELECTED)
1095  84E0 C6 40        	add 'A'-1
1096  84E2 32 7E 85     	ld  (MsgDrive), a
1097  84E5
1098  84E5 3A 21 86     	ld a, (FreeCatalog)
1099  84E8 6F           	ld l, a
1100  84E9 26 00        	ld h, 0
1101  84EB 11 97 85     	ld de, UsedCatMsg
1102  84EE CD FF 84     	call N2ASCII3
1103  84F1
1104  84F1              PrintStats:
1105  84F1 3E 00        	ld	a, 0
1106  84F3 CD 01 16     	call ROM_OPEN_SCR
1107  84F6 21 4A 85     	ld hl, FreeSpaceMsg
1108  84F9 06 58        	ld b, FreeSpaceMsgEnd - FreeSpaceMsg
1109  84FB CD 27 80     	call PrintStr
1110  84FE C9           	ret
1111  84FF
1112  84FF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Number routines ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1113  84FF
1114  84FF              ;Converts the 3 digit number in HL to ASCII at DE
1115  84FF              N2ASCII3:
1116  84FF D5           	push de
1117  8500 CD 30 85     		call N2ASCII_DEC3
1118  8503 D1           	pop de
1119  8504 01 00 02     	ld  bc, $0200
1120  8507 18 08        	jr StrippLoop
1121  8509
1122  8509              ;Converts the 5 digit number in HL to ASCII
1123  8509              N2ASCII5:
1124  8509 D5           	push de
1125  850A CD 24 85     		call N2ASCII_DEC
1126  850D D1           	pop de
1127  850E
1128  850E              StrippLeading0:
1129  850E 01 00 04     	ld bc, $0400
1130  8511              	;ld c, 0
1131  8511              StrippLoop:
1132  8511 1A           	ld a, (de)
1133  8512 FE 30        	cp '0'
1134  8514 20 09        	jr nz, MarkNon0
1135  8516 79           	ld a, c
1136  8517              	;cp 0
1137  8517 B7           	or a
1138  8518 20 06        	jr nz, NextChar
1139  851A 3E 20        	ld a, ' '
1140  851C 12           	ld (de), a
1141  851D 18 01        	jr NextChar
1142  851F              MarkNon0:
1143  851F 0C           	inc c
1144  8520              NextChar:
1145  8520 13           	inc de
1146  8521 10 EE        	djnz StrippLoop
1147  8523 C9           	ret
1148  8524
1149  8524
1150  8524              ;The folowing routine was inspired from: Milos "baze" Bazelides, baze@stonline.sk
1151  8524              ;http://map.tni.nl/sources/external/z80bits.html
1152  8524
1153  8524              ;Converts the number in HL to ASCII in decimal string at DE
1154  8524              N2ASCII_DEC:
1155  8524 01 F0 D8     	ld bc, -10000
1156  8527 CD 3F 85     	call DigitLoop
1157  852A 01 18 FC     	ld bc, -1000
1158  852D CD 3F 85     	call DigitLoop
1159  8530              N2ASCII_DEC3:
1160  8530 01 9C FF     	ld bc, -100
1161  8533 CD 3F 85     	call DigitLoop
1162  8536 01 F6 FF     	ld bc, -10
1163  8539 CD 3F 85     	call DigitLoop
1164  853C 01 FF FF     	ld bc, -1
1165  853F
1166  853F              DigitLoop:
1167  853F 3E 2F        	ld	a, '0' - 1
1168  8541              DivNrLoop:
1169  8541 3C           	inc	a			;increase reminder
1170  8542 09           	add	hl, bc		;substract divizor
1171  8543 38 FC        	jr	c, DivNrLoop	;still dividing?
1172  8545 ED 42        	sbc	hl, bc		;nope, restore
1173  8547
1174  8547 12           	ld (de), a
1175  8548 13           	inc de
1176  8549 C9           	ret
1177  854A
1178  854A
1179  854A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Allocated Data ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1180  854A
1181  854A              FreeSpaceMsg:
1182  854A 14 01        				DEFB	CLR_CODE_INVERSE, 1
1183  854C 13 01        				DEFB	CLR_CODE_BRIGHT, 1
1184  854E 11 01        				DEFB	CLR_CODE_PAPER, CLR_BLUE
1185  8550 10 06        				DEFB	CLR_CODE_INK, CLR_YELLOW
1186  8552 31 2F        ScrPageMsg		DEFB	"1/"
1187  8554 31           ScrPageMsgMax	DEFB	"1"
1188  8555 10 05 46 49  				DEFB	CLR_CODE_INK, CLR_NAME, "FILENAME"
1188  8559 4C 45 4E 41
1188  855D 4D 45
1189  855F 10 06 4C 45  				DEFB	CLR_CODE_INK, CLR_LEN, "LEN B"
1189  8563 4E 20 42
1190  8566 10 02 2B 52  				DEFB    CLR_CODE_INK, CLR_RO, "+R/O"
1190  856A 2F 4F
1191  856C 10 03 2B 53  				DEFB 	CLR_CODE_INK, CLR_SYS, "+SYS"
1191  8570 59 53
1192  8572 10 04 2B 52  				DEFB 	CLR_CODE_INK, CLR_RO_SYS, "+R/O+SYS"
1192  8576 2F 4F 2B 53
1192  857A 59 53
1193  857C
1194  857C 10 05        				DEFB	CLR_CODE_INK, CLR_CYAN
1195  857E 41 3A 20     MsgDrive		DEFB	"A: "
1196  8581 10 02        				DEFB	CLR_CODE_INK, CLR_RED
1197  8583 20 20 20 4B  UsedSpaceAsc	DEFM	"   KB"
1197  8587 42
1198  8588 20 20 20 46  FileCntMsg		DEFM    "   FILES"
1198  858C 49 4C 45 53
1199  8590 10 04        				DEFB	CLR_CODE_INK, CLR_GREEN
1200  8592 20 20 20 4B  FreeSpaceAsc	DEFM	"   KB"
1200  8596 42
1201  8597 20 20 20 44  UsedCatMsg		DEFM 	"   DIR FREE"
1201  859B 49 52 20 46
1201  859F 52 45 45
1202  85A2              FreeSpaceMsgEnd:
1203  85A2
1204  85A2
1205  85A2              DisplayedLine:
1206  85A2 17           				DEFB	CLR_CODE_TAB						;tab
1207  85A3 00 00        TabChar			DEFB	0, 0
1208  85A5 11 01        				DEFB	CLR_CODE_PAPER, CLR_BLUE
1209  85A7 13           				DEFM	CLR_CODE_BRIGHT
1210  85A8 00           DisplayedBright	DEFB	0				;bright is alternating
1211  85A9 10           				DEFB	CLR_CODE_INK
1212  85AA 05           FileNameClr		DEFB	CLR_NAME
1213  85AB 3F 3F 3F 3F  FileName		DEFM	"???????????"
1213  85AF 3F 3F 3F 3F
1213  85B3 3F 3F 3F
1214  85B6 10 06        				DEFB	CLR_CODE_INK, CLR_LEN
1215  85B8 20 20 20 20  FileLen			DEFB	"     "
1215  85BC 20
1216  85BD              DisplayedLineEnd:
1217  85BD
1218  85BD 11 02 13 01  MsgError		DEFB	CLR_CODE_PAPER, CLR_RED, CLR_CODE_BRIGHT, 1
1219  85C1 45 72 72 6F  				DEFM	"Error "
1219  85C5 72 20
1220  85C7 20 20 20 3A  MsgErrCode		DEFM	"   : "
1220  85CB 20
1221  85CC              MsgErrorEnd
1222  85CC
1223  85CC 13 01 10 07  MsgIntro		DEFM	CLR_CODE_BRIGHT, 1 ,CLR_CODE_INK, CLR_WHITE, CLR_CODE_PAPER, CLR_RED
1223  85D0 11 02
1224  85D2 43 55 52 53  				DEFM	"CURSOR+CR=RUN;1/2=A:/B:;ESC=EXIT"
1224  85D6 4F 52 2B 43
1224  85DA 52 3D 52 55
1224  85DE 4E 3B 31 2F
1224  85E2 32 3D 41 3A
1224  85E6 2F 42 3A 3B
1224  85EA 45 53 43 3D
1224  85EE 45 58 49 54
1225  85F2 7F 32 30 32  				DEFM	127, "2022 GEORGE.CHIRTOACA@GMAIL.COM"
1225  85F6 32 20 47 45
1225  85FA 4F 52 47 45
1225  85FE 2E 43 48 49
1225  8602 52 54 4F 41
1225  8606 43 41 40 47
1225  860A 4D 41 49 4C
1225  860E 2E 43 4F 4D
1226  8612              MsgIntroEnd:
1227  8612
1228  8612              ;the search mask
1229  8612 3F 3F 3F 3F  FileMask		DEFM	"???????????"
1229  8616 3F 3F 3F 3F
1229  861A 3F 3F 3F
1230  861D              END
1231  861D
1232  861D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Unalocated Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1233  861D
1234  861D              DRIVE_SELECTED	EQU		FileMask + NAMELEN
1235  861D              FileCnt			EQU		DRIVE_SELECTED + 1		;file index for display
1236  861D              UsedKB			EQU		FileCnt + 1
1237  861D              FreeCatalog		EQU		UsedKB + 2
1238  861D              SelFileIdxScr	EQU		FreeCatalog + 1
1239  861D              FileCntScr		EQU		SelFileIdxScr + 1
1240  861D              Cache			EQU		FileCntScr + 1				;here goes the cache table
1241  861D
1242  861D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1243  861D
1244  861D              START_ADDR		EQU	32768		;Start address
1245  861D
1246  861D              ;System variables for disk
1247  861D              VAR_DSTR1		EQU	$5CD6		;drive
1248  861D              VAR_FSTR1		EQU	$5CDC		;file name
1249  861D              VAR_NSTR1		EQU	$5CDA		;name length
1250  861D              VAR_HD11		EQU	$5CED		;BDOS argument
1251  861D              VAR_COPIES		EQU	$5CEF		;BDOS function
1252  861D              VAR_IOBORD		EQU	23750		;IO border
1253  861D              VAR_ATTR		EQU 23693		;color attribute
1254  861D              VAR_BORDCR		EQU 23624
1255  861D
1256  861D              VAR_SCROLL		EQU	23692
1257  861D              VAR_SCROLL2		EQU	23659
1258  861D              VAR_BORDER		EQU	$5C47
1259  861D              VAR_ERRSP		EQU $5C3D
1260  861D              VAR_ERRNR		EQU $5C3A
1261  861D              VAR_REPDEL		EQU	23561
1262  861D
1263  861D              ;IF1
1264  861D              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
1265  861D              ERRMSG			EQU	$0260
1266  861D
1267  861D              DRIVE_CURRENT	EQU 0
1268  861D              DRIVE_A			EQU	1
1269  861D              DRIVE_B			EQU	2
1270  861D
1271  861D              ;File name stuff
1272  861D              NAMELEN			EQU	11			;name length
1273  861D              ATTR_RO_POS		EQU	8			;read-only attribute position in name
1274  861D              ATTR_SYS_POS	EQU	9			;system attribute position in name
1275  861D
1276  861D              ;Disk geometry stuff
1277  861D              SPT				EQU	16			;sectors per track
1278  861D              SECT_SZ			EQU	256			;sector size in bytes
1279  861D              TRACK_CNT		EQU	80			;track count
1280  861D              HEAD_CNT		EQU	2			;disk face count
1281  861D              AU_SZ			EQU	2048		;allocation unit size in bytes
1282  861D              DIR_ENT_SZ		EQU	32			;directory entry size
1283  861D              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
1284  861D              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
1285  861D              MAX_DIR_ENT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / DIR_ENT_SZ);maximum directory entries
1286  861D              MAX_AU_CNT		EQU	(TRACK_CNT * HEAD_CNT * SPT * SECT_SZ)/AU_SZ
1287  861D              MAX_FREE_AU_CNT	EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units
1288  861D              REC_SZ			EQU 128			;cp/m record size
1289  861D              FINISH_CHR		EQU $1A			;file terminator char
1290  861D
1291  861D              ;File header offsets
1292  861D              HDR_TYPE		EQU	0
1293  861D              HDR_LEN			EQU 1
1294  861D              HDR_ADDR		EQU 3
1295  861D              HDR_VAR			EQU	5
1296  861D              HDR_LINE		EQU 7
1297  861D              HDR_SIZE		EQU 9
1298  861D
1299  861D              ;Disk cache table structure
1300  861D              CACHE_NAME		EQU 0
1301  861D              CACHE_RC_CNT	EQU NAMELEN
1302  861D              CACHE_LN_SZ		EQU NAMELEN +2
1303  861D
1304  861D              ;BASIC disk channel structure
1305  861D              CH_RW_FLAG		EQU 11
1306  861D              CH_FCB			EQU	12
1307  861D              CH_DATA			EQU	50
1308  861D              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
1309  861D
1310  861D              ;Extension structure (directory entry)
1311  861D              EXT_DEL_FLAG	EQU	0
1312  861D              EXT_NAME		EQU 1
1313  861D              EXT_IDX			EQU 12
1314  861D              EXT_S1			EQU 13
1315  861D              EXT_S2			EQU 14
1316  861D              EXT_RC			EQU	15
1317  861D              EXT_AU0			EQU	16
1318  861D              EXT_AU1			EQU	18
1319  861D              EXT_AU2			EQU	20
1320  861D              EXT_AU3			EQU	22
1321  861D              EXT_AU4			EQU	24
1322  861D              EXT_AU5			EQU	26
1323  861D              EXT_AU6			EQU	28
1324  861D              EXT_AU7			EQU	30
1325  861D              EXT_AU_CNT		EQU 8
1326  861D
1327  861D              ;FCB structure
1328  861D              FCB_DRIVE		EQU 0			;0 is current drive
1329  861D              FCB_NAME		EQU EXT_NAME
1330  861D              FCB_EX_IDX		EQU EXT_IDX
1331  861D              FCB_S1			EQU EXT_S1
1332  861D              FCB_S2			EQU EXT_S2
1333  861D              FCB_RC			EQU	EXT_RC
1334  861D              FCB_AU			EQU	EXT_AU0
1335  861D              FCB_CR			EQU	32
1336  861D              FCB_R0			EQU 33
1337  861D              FCB_R1			EQU 34
1338  861D              FCB_R2			EQU 35
1339  861D
1340  861D              ROM_OPEN_SCR	EQU	$1601
1341  861D              ROM_OPEN_SCR_CLR	EQU	$0DAF
1342  861D              ROM_PRINT		EQU $203C		;DE = string, BC = len
1343  861D
1344  861D              CLR_CODE_INK	EQU 16
1345  861D              CLR_CODE_PAPER	EQU 17
1346  861D              CLR_CODE_BRIGHT EQU	19
1347  861D              CLR_CODE_INVERSE EQU	20
1348  861D              CLR_CODE_TAB	EQU 23
1349  861D
1350  861D              CLR_BLACK		EQU	0
1351  861D              CLR_BLUE		EQU	1
1352  861D              CLR_RED			EQU	2
1353  861D              CLR_MAGENTA		EQU	3
1354  861D              CLR_GREEN		EQU	4
1355  861D              CLR_CYAN		EQU	5
1356  861D              CLR_YELLOW		EQU	6
1357  861D              CLR_WHITE		EQU	7
1358  861D
1359  861D              CLR_NAME		EQU CLR_CYAN
1360  861D              CLR_RO			EQU	CLR_RED
1361  861D              CLR_SYS			EQU	CLR_MAGENTA
1362  861D              CLR_RO_SYS		EQU	CLR_GREEN
1363  861D              CLR_LEN			EQU	CLR_YELLOW
1364  861D
1365  861D              SCR_ATTR_ADDR	EQU 22528
1366  861D              SCR_ATTR_LEN	EQU	768
1367  861D              SCR_COLUMNS		EQU	32
1368  861D              SCR_LINES		EQU 24
1369  861D
1370  861D              ;key codes
1371  861D              KEY_ESC			EQU	7
1372  861D              KEY_LEFT		EQU	8
1373  861D              KEY_RIGHT		EQU	9
1374  861D              KEY_DOWN		EQU	10
1375  861D              KEY_UP			EQU	11
1376  861D              KEY_ENTER		EQU	13
1377  861D              KEY_CTRL		EQU	14
1378  861D
1379  861D              MAX_FILES_SCR	EQU	44
1380  861D
1381  861D
1382  861D              				EMPTYTAP "cat.tap"
1383  861D              				savetap "cat.tap", CODE, "run", start, END-start
1384  861D              				savebin "cat.bin", start, END-start
1385  861D
# file closed: D:\Spectrum\src\HC\HCRun\cat.ASM

Value    Label
------ - -----------------------------------------------------------
0x000E X KEY_CTRL
0x0018 X SCR_LINES
0x0300 X SCR_ATTR_LEN
0x0003   CLR_MAGENTA
0x0000 X CLR_BLACK
0x203C X ROM_PRINT
0x0023 X FCB_R2
0x0022 X FCB_R1
0x0021 X FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000E X FCB_S2
0x000D X FCB_S1
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0008 X EXT_AU_CNT
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x000C   EXT_IDX
0x0001   EXT_NAME
0x0000 X EXT_DEL_FLAG
0x0032   CH_DATA
0x000B X CH_RW_FLAG
0x000B X CACHE_RC_CNT
0x0000 X CACHE_NAME
0x0009 X HDR_SIZE
0x0007 X HDR_LINE
0x0005 X HDR_VAR
0x0003 X HDR_ADDR
0x0001 X HDR_LEN
0x0000 X HDR_TYPE
0x001A X FINISH_CHR
0x0080 X REC_SZ
0x0140 X MAX_AU_CNT
0x0008 X SPAL
0x0001   DIR_TRK_CNT
0x0020   DIR_ENT_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0100   SECT_SZ
0x0010   SPT
0x5C47 X VAR_BORDER
0x5C8C X VAR_SCROLL
0x5CC6 X VAR_IOBORD
0x861D   END
0x0017   CLR_CODE_TAB
0x0004   CLR_GREEN
0x0002   CLR_RED
0x0005   CLR_CYAN
0x0006   CLR_LEN
0x0006   CLR_YELLOW
0x0010   CLR_CODE_INK
0x0011   CLR_CODE_PAPER
0x0013   CLR_CODE_BRIGHT
0x0014   CLR_CODE_INVERSE
0x8541   DivNrLoop
0x853F   DigitLoop
0x8520   NextChar
0x851F   MarkNon0
0x850E X StrippLeading0
0x8524   N2ASCII_DEC
0x8511   StrippLoop
0x8530   N2ASCII_DEC3
0x85A2   FreeSpaceMsgEnd
0x854A   FreeSpaceMsg
0x84F1 X PrintStats
0x8597   UsedCatMsg
0x857E   MsgDrive
0x8588   FileCntMsg
0x8592   FreeSpaceAsc
0x0800   AU_SZ
0x013E   MAX_FREE_AU_CNT
0x8583   UsedSpaceAsc
0x84A8   FindCacheLoop
0x000F   FCB_RC
0x84A5   FindCacheByName
0x849A   Cat2Index0
0x84A1   CatEnd2
0x8460   CatNext2
0x8445   CatEnd
0x840F   CatNext
0x000C   FCB_EX_IDX
0x8612   FileMask
0x8621   FreeCatalog
0x0080   MAX_DIR_ENT
0x85AA   FileNameClr
0x0004   CLR_RO_SYS
0x0003   CLR_SYS
0x83E1   BothAttr
0x83E3   NotSys
0x0009   ATTR_SYS_POS
0x0002   CLR_RO
0x83CF   NotRO
0x0008   ATTR_RO_POS
0x0005   CLR_NAME
0x85BD   DisplayedLineEnd
0x85A2   DisplayedLine
0x839C   GoodChar
0x8393   FileNameCopy
0x83C1   CheckAttributes
0x85AB   FileName
0x8375   DisplayLoop
0x8369   DisplayFilesInfo
0x85A8   DisplayedBright
0x5C6B   VAR_SCROLL2
0x833E   FindCacheLineLoop
0x000D   CACHE_LN_SZ
0x831C X Page1of3
0x8322   Page2of3
0x8328   Page3of3
0x8305 X Page1of2
0x830B   Page2of2
0x8330   FindCacheLine
0x8313   ThreeScreensMax
0x8300   TwoScreensMax
0x82FC   OneScreenMax
0x82CA   DrawCursorLoop
0x0020   SCR_COLUMNS
0x5800   SCR_ATTR_ADDR
0x829C   CursorUpOrLeft
0x82B1   DrawCursor
0x827D   CursorDownValidSelection
0x826C   CursorDownOrRight
0x8261   PrevScr
0x8255   NextScr
0x0002   DRIVE_B
0x824E   SwitchDrive
0x8335   FindCacheByIndex
0x8622   SelFileIdxScr
0x8238   PageAddLoop
0x823C   FirstPageIndex
0x000D   KEY_ENTER
0x8298   CursorLeft
0x822A   CheckEnter
0x0008   KEY_LEFT
0x8290   CursorRight
0x8221   CheckKeyLeft
0x0009   KEY_RIGHT
0x8294   CursorUp
0x8218   CheckKeyRight
0x000B   KEY_UP
0x828C   CursorDown
0x820F   CheckKeyUp
0x000A   KEY_DOWN
0x824C   SelectDriveB
0x8248   SelectDriveA
0x0007   KEY_ESC
0x8342   DisplayOneScreen
0x8623   FileCntScr
0x82E5   GetFileListForScreen
0x85A3   TabChar
0x81E9   DisplayFilesLoop
0x002C   MAX_FILES_SCR
0x81E3   ScreenCntLoop
0x84BA   DisplayStats
0x81E0   NonEmptyDisk
0x8554   ScrPageMsgMax
0x8552   ScrPageMsg
0x8509   N2ASCII5
0x85B8   FileLen
0x81B9   BigFile
0x819E   DisplayFileLength
0x8199   NoPartialAU
0x861F   UsedKB
0x8180   GetFileSizeOnDiskKB
0x8164   FileSizeLoop
0x861E   FileCnt
0x0A41   LOAD_ADDR
0x0000   DRIVE_CURRENT
0x000B   NAMELEN
0x8145   LoadProgram
0x0026   CH_DMA
0x8136   SetDMA
0x8132   FindNext
0x812E   FindFirst
0x861D   DRIVE_SELECTED
0x5CEF   VAR_COPIES
0x810E   BDOS
0x8106   DestroyChannel
0x000C   CH_FCB
0x5CDA   VAR_NSTR1
0x5CD6   VAR_DSTR1
0x5CDC   VAR_FSTR1
0x80F1   CreateChannel
0x80E0   CopyMsg
0x80D2   SearchMsgEnd
0x80DB   SaveMsg
0x0260   ERRMSG
0x5CED   VAR_HD11
0x80C9   IF1Paged
0x80B8   DontSelectA
0x8624   Cache
0x80BE   GetErrMsg
0x85CC   MsgErrorEnd
0x85BD   MsgError
0x84FF   N2ASCII3
0x85C7   MsgErrCode
0x5C3A   VAR_ERRNR
0x8612   MsgIntroEnd
0x85CC   MsgIntro
0x1601   ROM_OPEN_SCR
0x0DAF   ROM_OPEN_SCR_CLR
0x5C8D   VAR_ATTR
0x5C48   VAR_BORDCR
0x0007   CLR_WHITE
0x0001   CLR_BLUE
0x811C   SelectDrive
0x0001   DRIVE_A
0x805B   SelectDriveInit
0x8059   CurrentDriveNone
0x812A   GetCurrentDrive
0x8118   InitDos
0x80EE   InitVars
0x8046   MisMatch
0x803E   Compare
0x803C   StrCmp
0x5C09   VAR_REPDEL
0x8031   SetFastKeys
0x8027   PrintStr
0x8024   ReadChar
0x81F8   ReadCharLoop
0x81CB   DisplayFiles
0x815D   GetDiskUsedSpace
0x8449   ReadCatalog2
0x83E7   ReadCatalog1
0x800F   ReadDiskAgain
0x8049   Init
0x8080   ErrorHandler
0x5C3D   VAR_ERRSP
0x8000   start
0x8000   START_ADDR
