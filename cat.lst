# file opened: D:\Spectrum\src\HC\HCRun\cat.ASM
   1  0000              ;File listing program for HC
   2  0000              ;George Chirtoaca, george.chirtoaca(@)gmail(.)com, March 2022
   3  0000              ;
   4  0000              ;The purpose of this program is to have a fast file listing, that includes hidden files and also shows the file size and file attributes using colours on screen.
   5  0000              ;File selection will be possible with arrow keys, to select BASIC programs and run them, making it usefull as "run" program for auto-run on HC floppy disks. That's why it tries to be small and fast.
   6  0000              ;Reading the exact file size and file type requires opening up each file, which is slow, so it's not performed. The aproximate file size provided (rounded at 128 bytes) can be used as a hint to guess the file type.
   7  0000              ;Smaller files should be the BASIC loaders (around 256 bytes). SCREEN$ files are 7168 bytes. Larger files are code files usually. Files bigger than 64K are shown with file size in kilobytes.
   8  0000              ;Can display up to 128 files (max supported by HC BASIC file system), grouped in up to 3 pages, 44 files per page. Most disks will have one page listing, quickly showing up all disk info on one screen.
   9  0000              ;System calls are kept at minimum, because are slow. The aproximate file size is determined by processing all file dir entries and summing up the record count instead of calling the system call for file size determination.
  10  0000              ;Free space is determined by summing up file sizes on disk and substracting from maximum possible size (636KB). This allows showing up the ocupied space too, that the ROM doesn't list.
  11  0000              ;Another way to determine space would be to make the system call to get disk the allocation bitmap, but that bitmap is in "phantom RAM" (IF1 paged RAM) so it's more convoluted to read and process it (count set bits).
  12  0000              ;Would be probably faster to process the disk directory by reading the sectors and parsing manually, but that requires more code, and one objective was to have small and clear code. So system calls are used for Find First/Next.
  13  0000              ;Mathematical operations like multiplication and division are performed using bit shifts, since involve numbers that are power of 2. Again this is for having simple and small code.
  14  0000              ;Printing the text uses the BASIC ROM routine, that supports embedded color codes. The IF1 print routine doesn't support that. Direct screen output would be another way, but requires more code. Graphical output (64 columns) was excluded for the same reason.
  15  0000              ;ROM printing routing has an issue with line 21 (out of 0-23), so a trick is used to avoid scrolling: channel 0 is used for the stats printing, then lines 0-21 are printed on channel 2, also poking a variable to prevent scrolling.
  16  0000              ;The disk drive being displayed is the current drive, so the program should work as expected when executed from drive B:, as it doesn't hard code A:. A: is assumed when there's no current drive (like when loading from tape).
  17  0000              ;What was used to develop this program:
  18  0000              ; - SjASMPlus v1.18.2 cross-assembler
  19  0000              ; - Crimson Editor for editing, launching assembler, deploying in emulator
  20  0000              ; - HC 2000 Emulator for Sinclair Spectrum +3 by Rares Atodiresei, for using the Spectaculator emulator with HC-2000 emulation support
  21  0000              ; - Spectaculator emulator, for using the debugger and it's other top quality features
  22  0000              ; - Fuse emulator, version from Alex Badea, with HC-2000 emulation support, for double testing
  23  0000              ; - HCDisk2 by myself, for creating/updating disk images for HC in DSK format.
  24  0000              ;
  25  0000              ;Motivation?
  26  0000              ; - I wanted to refresh my Z80 assembly language
  27  0000              ; - I wanted to create an usefull tool for HC computers, with features that don't exist yet
  28  0000              ; - I wanted to publish the code, in case it's usefull in understanding how HC computers disk system works
  29  0000              ;I realise some people may find it useless, but it's still a good exercise for myself and others.
  30  0000              ;
  31  0000              ;How it works:
  32  0000              ;1. Reads disk catalog and saves a line in a table for each file, with info from directory entry 0: file name, RC count.
  33  0000              ;2. Reads disk catalog again, to read the total record count for each file. This second pass is required because some files may have dir entry 1 show up before dir entry 0.
  34  0000              ;3. Calculates disk space used by files, based on cache table record count, rounding up to 2048 (block size).
  35  0000              ;4. Displays total used space on disk, file count, disk free space, listing page 1/2/3.
  36  0000              ;5. Displays file list and file size in bytes, rounded up at 128 (CPM style). File attributes are shown in color, as noted on screen: red=read only, magenta=system (hidden from CAT), yellow=read only + system.
  37  0000
  38  0000              				DEVICE ZXSPECTRUM48
  39  0000
  40  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main program ;;;;;;;;;;;;;;;;;;;;;;;;;;
  41  0000              	ORG START_ADDR
  42  8000
  43  8000              start:
  44  8000              	;install error handler
  45  8000 2A 3D 5C     	ld		hl, (VAR_ERRSP)
  46  8003 E5           	push	hl
  47  8004 21 80 80     	ld		hl, ErrorHandler
  48  8007 E5           	push	hl
  49  8008 ED 73 3D 5C  	ld		(VAR_ERRSP), sp
  50  800C
  51  800C              	;Init IF1, disk
  52  800C CD 49 80     	call Init
  53  800F
  54  800F              ReadDiskAgain:
  55  800F              	;First read of catalog, to get file list
  56  800F CD E2 83     	call ReadCatalog1
  57  8012              	;Second read of catalog, to get file size
  58  8012 CD 44 84     	call ReadCatalog2
  59  8015              	;Calculate space used by files on disk
  60  8015 CD 5D 81     	call GetDiskUsedSpace
  61  8018              	;Display list of files
  62  8018 CD CB 81     	call DisplayFiles
  63  801B
  64  801B CD F8 81     	call ReadCharLoop
  65  801E
  66  801E              	;restore default error handler
  67  801E E1           	pop		hl
  68  801F E1           	pop		hl
  69  8020 22 3D 5C     	ld		(VAR_ERRSP), hl
  70  8023
  71  8023 C9           	ret
  72  8024
  73  8024              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Char routines ;;;;;;;;;;;;;;;;;;;;;;;;;
  74  8024
  75  8024
  76  8024              ;Return read char in A
  77  8024              ReadChar:
  78  8024 CF           	rst 08
  79  8025 1B           	DEFB 27
  80  8026 C9           	ret
  81  8027
  82  8027              ;Print a string
  83  8027              ;HL=str. addr.
  84  8027              ;B=len
  85  8027              PrintStr:
  86  8027 7E           	ld a, (hl)
  87  8028 E5           	push hl
  88  8029 C5           	push bc
  89  802A D7           		rst $10				;Print using ROM routine, since it supports color output. The IF1 print routine doesn't.
  90  802B C1           	pop bc
  91  802C E1           	pop hl
  92  802D 23           	inc hl
  93  802E 10 F7        	djnz PrintStr
  94  8030 C9           	ret
  95  8031
  96  8031              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  97  8031              SetFastKeys:
  98  8031 21 09 5C     	ld		hl, VAR_REPDEL
  99  8034 11 0F 01     	ld		de, (1 << 8) | 15
 100  8037 73 23 72 2B  	ld		(hl), de
 101  803B C9           	ret
 102  803C
 103  803C              ;Compare string at HL with the one at DE, max length B
 104  803C              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 105  803C              ;OUT: z flag, set = match, reset = mismatch
 106  803C              StrCmp:
 107  803C E5           	push hl
 108  803D D5           	push de
 109  803E              Compare:
 110  803E 1A           		ld a, (de)
 111  803F BE           		cp (hl)
 112  8040 20 04        		jr nz, MisMatch
 113  8042 23           		inc hl
 114  8043 13           		inc de
 115  8044 10 F8        		djnz Compare
 116  8046              MisMatch:
 117  8046 D1           	pop de
 118  8047 E1           	pop hl
 119  8048 C9           	ret
 120  8049
 121  8049              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 122  8049
 123  8049              Init:
 124  8049              ;These 2 calls are not needed when this program is launched from disk, as it will display the current disk.
 125  8049              ;If loaded from tape, it won't work without the 2 calls, since they are needed for DOS initialisation and selecting A: or B:.
 126  8049 CD EE 80     	call InitVars
 127  804C CD 18 81     	call InitDos
 128  804F
 129  804F              	;Select the current drive to work with instead of hardcoding A:.
 130  804F CD 2A 81     	call GetCurrentDrive
 131  8052 FE FF        	cp $FF							;$FF = no current drive, force A:
 132  8054 28 03        	jr  z, CurrentDriveNone
 133  8056 3C           	inc  a							;translate CP/M drive to BASIC drive: 0 -> 1, 1 -> 2
 134  8057 18 02        	jr  SelectDriveInit
 135  8059              CurrentDriveNone:
 136  8059 3E 01        	ld  a, DRIVE_A
 137  805B              SelectDriveInit:
 138  805B CD 1C 81     	call SelectDrive
 139  805E
 140  805E              	;set border and paper to blue
 141  805E 3E 01        	ld  a, CLR_BLUE
 142  8060 D3 FE        	out ($FE), a
 143  8062 3E 0F        	ld a, (CLR_BLUE << 3) | CLR_WHITE
 144  8064 32 48 5C     	ld (VAR_BORDCR), a
 145  8067 32 8D 5C     	ld (VAR_ATTR), a
 146  806A
 147  806A              	;CLS
 148  806A 3E 02        	ld  a, 2
 149  806C CD AF 0D     	call ROM_OPEN_SCR_CLR
 150  806F
 151  806F 3E 00        	ld  a, 0
 152  8071 CD 01 16     	call ROM_OPEN_SCR
 153  8074 21 C7 85     	ld  hl, MsgIntro
 154  8077 06 44        	ld  b, MsgIntroEnd - MsgIntro
 155  8079 CD 27 80     	call PrintStr
 156  807C
 157  807C CD 31 80     	call SetFastKeys
 158  807F
 159  807F C9           	ret
 160  8080
 161  8080
 162  8080              ErrorHandler:
 163  8080 E1           	pop		hl
 164  8081 22 3D 5C     	ld		(VAR_ERRSP), hl
 165  8084
 166  8084 3E 02        	ld		a, 2
 167  8086 CD AF 0D     	call	ROM_OPEN_SCR_CLR
 168  8089
 169  8089 3E 00        	ld		a, 0
 170  808B CD 01 16     	call	ROM_OPEN_SCR
 171  808E
 172  808E 3A 3A 5C     	ld		a, (VAR_ERRNR)
 173  8091 F5           	push	af
 174  8092 6F           	ld		l, a
 175  8093 26 00        	ld		h, 0
 176  8095 11 C2 85     	ld		de, MsgErrCode
 177  8098 CD FA 84     	call	N2ASCII3
 178  809B
 179  809B 21 B8 85     	ld		hl, MsgError
 180  809E 06 0F        	ld		b, MsgErrorEnd - MsgError
 181  80A0 CD 27 80     	call	PrintStr
 182  80A3
 183  80A3 F1           	pop		af
 184  80A4 F5           	push	af
 185  80A5 CD BE 80     	call	GetErrMsg
 186  80A8 21 1D 86     	ld		hl, Cache
 187  80AB CD 27 80     	call	PrintStr
 188  80AE
 189  80AE              	;On disk error, select A:, in case drive B: was empty when selected.
 190  80AE F1           	pop		af
 191  80AF FE 10        	cp		$10
 192  80B1 20 05        	jr		nz, DontSelectA
 193  80B3 3E 01        	ld		a, DRIVE_A
 194  80B5 CD 1C 81     	call	SelectDrive
 195  80B8
 196  80B8              DontSelectA:
 197  80B8 CD 24 80     	call	ReadChar
 198  80BB C3 00 80     	jp		start
 199  80BE
 200  80BE
 201  80BE              ;IN DE = message destination
 202  80BE              GetErrMsg:
 203  80BE 3C           	inc		a
 204  80BF 08           	ex		af, af'
 205  80C0
 206  80C0 21 C9 80     	ld		hl, IF1Paged			;page-in IF1
 207  80C3 22 ED 5C     	ld		(VAR_HD11), hl
 208  80C6 CF           	rst		8
 209  80C7 32           	defb	50
 210  80C8 C9           	ret								;return after accesing IF1
 211  80C9
 212  80C9              IF1Paged:
 213  80C9 21 60 02     	ld		hl, ERRMSG
 214  80CC 08           	ex		af, af'
 215  80CD B7           	or		a
 216  80CE 28 0B        	jr		z, SaveMsg
 217  80D0
 218  80D0 06 00        	ld		b, 0
 219  80D2              SearchMsgEnd:
 220  80D2 CB 7E        	bit		7, (hl)
 221  80D4 23           	inc		hl
 222  80D5 28 FB        	jr		z, SearchMsgEnd
 223  80D7
 224  80D7 04           	inc		b
 225  80D8 B8           	cp		b
 226  80D9 20 F7        	jr		nz, SearchMsgEnd
 227  80DB
 228  80DB              SaveMsg:
 229  80DB 11 1D 86     	ld		de, Cache
 230  80DE 06 00        	ld		b, 0
 231  80E0              CopyMsg:
 232  80E0 7E           	ld		a, (hl)
 233  80E1 12           	ld		(de), a
 234  80E2 23           	inc		hl
 235  80E3 13           	inc		de
 236  80E4 04           	inc		b
 237  80E5 CB 7F        	bit		7, a
 238  80E7 28 F7        	jr		z, CopyMsg
 239  80E9 EB           	ex		de, hl
 240  80EA 2B           	dec		hl
 241  80EB CB BE        	res		7, (hl)
 242  80ED C9           	ret
 243  80EE
 244  80EE
 245  80EE
 246  80EE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Disk routines ;;;;;;;;;;;;;;;;;;;;;;;;;
 247  80EE
 248  80EE              ;Insert IF1 variables
 249  80EE              InitVars:
 250  80EE CF           	rst 08
 251  80EF 31           	DEFB 49
 252  80F0 C9           	ret
 253  80F1
 254  80F1              ;Create a disk channel for BDOS access (does not open the file)
 255  80F1              ;IN: HL=name addr, B=drive, C=name len
 256  80F1              ;OUT: IX=FCB
 257  80F1              CreateChannel:
 258  80F1 22 DC 5C     	ld (VAR_FSTR1), hl
 259  80F4 26 00        	ld h,0
 260  80F6 68           	ld l,b
 261  80F7 22 D6 5C     	ld (VAR_DSTR1), hl
 262  80FA 69           	ld l,c
 263  80FB 22 DA 5C     	ld (VAR_NSTR1), hl
 264  80FE CF           	rst 08
 265  80FF 37           	DEFB 55
 266  8100 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
 267  8103 DD 09        	add ix, bc
 268  8105 C9           	ret
 269  8106
 270  8106
 271  8106              ;Destroy a BDOS channel
 272  8106              ;IN: IX=FCB
 273  8106              DestroyChannel:
 274  8106 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
 275  8109 DD 09        	add ix, bc
 276  810B CF           	rst 08
 277  810C 38           	DEFB 56
 278  810D C9           	ret
 279  810E
 280  810E
 281  810E              ;Generic BDOS call
 282  810E              ;IX=arg, A=function
 283  810E              BDOS:
 284  810E DD 22 ED 5C  	ld (VAR_HD11), ix
 285  8112 32 EF 5C     	ld (VAR_COPIES), a
 286  8115 CF           	rst 08
 287  8116 39           	DEFB 57
 288  8117 C9           	ret
 289  8118
 290  8118              InitDos:
 291  8118 3E 00        	ld	a, 0
 292  811A 18 F2        	jr	BDOS
 293  811C
 294  811C              ;IN A=selected drive
 295  811C              SelectDrive:
 296  811C 32 16 86     	ld  (DRIVE_SELECTED), a
 297  811F 3D           	dec a		;CPM drive is 0=A or 1=B. For BASIC is 1=A, 2=B, 0=current drive. So we must convert it for the CPM call, otherwise the BDOS function crashes.
 298  8120 DD 26 00     	ld  ixh, 0
 299  8123 DD 6F        	ld	ixl, a	;0=A, 1=B
 300  8125 3E 01        	ld	a, 1	;1=Select disk
 301  8127 18 E5        	jr	BDOS
 302  8129 C9           	ret
 303  812A
 304  812A              ;Returns current disk in A: 0=A:, 1=B:, $FF=no current drive
 305  812A              GetCurrentDrive:
 306  812A 3E 0C        	ld a, 12
 307  812C 18 E0        	jr BDOS
 308  812E
 309  812E              ;FindFirst
 310  812E              ;IX=fcb
 311  812E              FindFirst:
 312  812E 3E 04        	ld a, 4
 313  8130 18 DC        	jr BDOS
 314  8132
 315  8132
 316  8132              ;FindNext
 317  8132              ;IX=fcb
 318  8132              FindNext:
 319  8132 3E 05        	ld a, 5
 320  8134 18 D8        	jr BDOS
 321  8136
 322  8136
 323  8136              ;Set DMA address for BDOS into the already alocated (and unused) 256 bytes channel buffer
 324  8136              ;IX=fcb
 325  8136              SetDMA:
 326  8136 01 26 00     	ld bc, CH_DMA		;offset into alocated data area of the channel (256 bytes)
 327  8139 DD E5        	push ix
 328  813B DD 09        		add ix, bc
 329  813D 3E 0D        		ld a, 13
 330  813F CD 0E 81     		call BDOS
 331  8142 DD E1        	pop ix
 332  8144 C9           	ret
 333  8145
 334  8145              ;Load a program from disk
 335  8145              ;IN: HL = file name addr
 336  8145              LoadProgram:
 337  8145 22 DC 5C     	LD   (VAR_FSTR1), HL
 338  8148 26 00        	LD   H, 0
 339  814A 2E 0B        	LD   L, NAMELEN
 340  814C 22 DA 5C     	LD   (VAR_NSTR1), HL
 341  814F              	;LD	 A, (DRIVE_SELECTED)
 342  814F 2E 00        	LD   L, DRIVE_CURRENT
 343  8151 22 D6 5C     	LD   (VAR_DSTR1), HL
 344  8154 21 41 0A     	LD   HL, LOAD_ADDR
 345  8157 22 ED 5C     	LD   (VAR_HD11), HL
 346  815A CF           	RST  8
 347  815B 32           	DEFB 50
 348  815C C9           	RET
 349  815D
 350  815D
 351  815D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 352  815D
 353  815D              ;Sum up file size on disk for all files. It's easier than parsing the block bitmap in phantom RAM.
 354  815D              GetDiskUsedSpace:
 355  815D 21 1D 86     	ld		hl, Cache
 356  8160 3A 17 86     	ld		a, (FileCnt)
 357  8163 47           	ld		b, a
 358  8164
 359  8164              FileSizeLoop:
 360  8164 C5           	push	bc
 361  8165 01 0B 00     		ld		bc, NAMELEN
 362  8168 09           		add		hl, bc
 363  8169
 364  8169 4E           		ld		c, (hl)
 365  816A 23           		inc		hl
 366  816B 46           		ld		b, (hl)
 367  816C 23           		inc		hl
 368  816D
 369  816D E5           		push	hl
 370  816E C5           			push	bc
 371  816F E1           			pop		hl
 372  8170 CD 80 81     			call	GetFileSizeOnDiskKB
 373  8173
 374  8173 ED 4B 18 86  			ld		bc, (UsedKB)
 375  8177 09           			add		hl, bc
 376  8178 22 18 86     			ld		(UsedKB), hl
 377  817B E1           		pop		hl
 378  817C C1           	pop		bc
 379  817D 10 E5        	djnz	FileSizeLoop
 380  817F C9           	ret
 381  8180
 382  8180
 383  8180              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 384  8180
 385  8180              ;IN HL=RC count
 386  8180              ;OUT HL = File size on disk in KB
 387  8180              ;(RC count * 128) / 2048 = RC count * 16 = block count. Block count * 2 = KB on disk
 388  8180              GetFileSizeOnDiskKB:
 389  8180 AF           	xor a
 390  8181
 391  8181              	;/2
 392  8181 CB 3C        	srl	h
 393  8183 CB 1D        	rr	l
 394  8185 17           	rla
 395  8186              	;/4
 396  8186 CB 3C        	srl	h
 397  8188 CB 1D        	rr	l
 398  818A 17           	rla
 399  818B              	;/8
 400  818B CB 3C        	srl	h
 401  818D CB 1D        	rr	l
 402  818F 17           	rla
 403  8190              	;/16
 404  8190 CB 3C        	srl	h
 405  8192 CB 1D        	rr	l
 406  8194 17           	rla
 407  8195
 408  8195 B7           	or  a
 409  8196 28 01        	jr  z, NoPartialAU
 410  8198 23           	inc	hl
 411  8199              NoPartialAU:
 412  8199
 413  8199              	;block count * 2 = KB
 414  8199 CB 25        	sla	l
 415  819B CB 14        	rl	h
 416  819D C9           	ret
 417  819E
 418  819E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 419  819E
 420  819E              ;IN HL = RC count
 421  819E              DisplayFileLength:
 422  819E              	;check if RC >= $200 RC, to display size in KB then, as it doesn't fit in 16 bits.
 423  819E 3E 02        	ld  a, 2
 424  81A0 94           	sub h
 425  81A1 38 16        	jr  c, BigFile
 426  81A3
 427  81A3              	;RC * 128 = size in bytes rounded at 128.
 428  81A3              	;h << 7
 429  81A3 CB 0C        	rrc h
 430  81A5              	;l >> 1
 431  81A5 CB 3D        	srl l
 432  81A7              	;save carry	in H
 433  81A7 CB 1C        	rr h
 434  81A9              	;save L
 435  81A9 7D           	ld  a, l
 436  81AA 2E 00        	ld  l, 0
 437  81AC              	;save bit 7 of L
 438  81AC CB 14        	rl h
 439  81AE CB 1D        	rr l
 440  81B0              	;save H + 7 bits of L
 441  81B0 B4           	or  h
 442  81B1 67           	ld  h, a
 443  81B2
 444  81B2 11 B3 85     	ld  de, FileLen
 445  81B5 CD 04 85     	call N2ASCII5
 446  81B8
 447  81B8 C9           	ret
 448  81B9
 449  81B9              BigFile:
 450  81B9 CD 80 81     	call GetFileSizeOnDiskKB
 451  81BC
 452  81BC 11 B3 85     	ld  de, FileLen
 453  81BF CD FA 84     	call N2ASCII3
 454  81C2 13           	inc  de
 455  81C3 3E 4B        	ld  a, 'K'
 456  81C5 12           	ld  (de), a
 457  81C6 13           	inc de
 458  81C7 3E 42        	ld  a, 'B'
 459  81C9 12           	ld  (de), a
 460  81CA
 461  81CA C9           	ret
 462  81CB
 463  81CB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 464  81CB              DisplayFiles:
 465  81CB 3E 31        	ld  a, '1'
 466  81CD 32 51 85     	ld  (ScrPageMsg), a
 467  81D0 32 53 85     	ld  (ScrPageMsgMax), a
 468  81D3
 469  81D3 3A 17 86     	ld a, (FileCnt)
 470  81D6 B7           	or a
 471  81D7 20 07        	jr  nz, NonEmptyDisk
 472  81D9 CD B5 84     	call DisplayStats
 473  81DC CD 24 80     	call ReadChar
 474  81DF C9           	ret
 475  81E0
 476  81E0              NonEmptyDisk:
 477  81E0              	;detemine how many file list pages we have (1-3)
 478  81E0 21 53 85     	ld hl, ScrPageMsgMax
 479  81E3              ScreenCntLoop:
 480  81E3 D6 2C        	sub MAX_FILES_SCR
 481  81E5 34           	inc (hl)
 482  81E6 30 FB        	jr  nc, ScreenCntLoop
 483  81E8 35           	dec (hl)
 484  81E9
 485  81E9              DisplayFilesLoop:
 486  81E9 AF           	xor a
 487  81EA 32 9E 85     	ld (TabChar), a
 488  81ED
 489  81ED CD E6 82     	call GetFileListForScreen
 490  81F0 78           	ld  a, b
 491  81F1 32 1C 86     	ld  (FileCntScr), a
 492  81F4 CD 42 83     	call DisplayOneScreen
 493  81F7 C9           	ret
 494  81F8
 495  81F8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 496  81F8
 497  81F8              ReadCharLoop:
 498  81F8 CD 24 80     	call ReadChar
 499  81FB FE 07        	cp  KEY_ESC
 500  81FD C8           	ret z
 501  81FE
 502  81FE FE 31        	cp  '1'
 503  8200 28 47        	jr  z, SelectDriveA
 504  8202 FE 32        	cp  '2'
 505  8204 28 47        	jr  z, SelectDriveB
 506  8206
 507  8206 FE 0A        	cp KEY_DOWN
 508  8208 20 05        	jr nz, CheckKeyUp
 509  820A CD 8D 82     	call CursorDown
 510  820D 18 E9        	jr ReadCharLoop
 511  820F
 512  820F              CheckKeyUp:
 513  820F FE 0B        	cp KEY_UP
 514  8211 20 05        	jr nz, CheckKeyRight
 515  8213 CD 95 82     	call CursorUp
 516  8216 18 E0        	jr ReadCharLoop
 517  8218
 518  8218              CheckKeyRight:
 519  8218 FE 09        	cp KEY_RIGHT
 520  821A 20 05        	jr nz, CheckKeyLeft
 521  821C CD 91 82     	call CursorRight
 522  821F 18 D7        	jr ReadCharLoop
 523  8221
 524  8221              CheckKeyLeft:
 525  8221 FE 08        	cp KEY_LEFT
 526  8223 20 05        	jr  nz, CheckEnter
 527  8225 CD 99 82     	call CursorLeft
 528  8228 18 CE        	jr  ReadCharLoop
 529  822A
 530  822A              CheckEnter:
 531  822A FE 0D        	cp KEY_ENTER
 532  822C 20 CA        	jr nz, ReadCharLoop
 533  822E
 534  822E              	;Read current screen.
 535  822E 3A 51 85     	ld a, (ScrPageMsg)
 536  8231 D6 31        	sub '1'
 537  8233 B7           	or  a
 538  8234 28 06        	jr  z, FirstPageIndex
 539  8236 47           	ld  b, a
 540  8237 AF           	xor a
 541  8238              PageAddLoop:
 542  8238 C6 2C        	add MAX_FILES_SCR
 543  823A 10 FC        	djnz PageAddLoop
 544  823C              FirstPageIndex:
 545  823C 21 1B 86     	ld hl, SelFileIdxScr
 546  823F 86           	add (hl)
 547  8240 47           	ld  b, a
 548  8241 CD 36 83     	call FindCacheByIndex
 549  8244 CD 45 81     	call LoadProgram
 550  8247 18 AF        	jr ReadCharLoop
 551  8249
 552  8249              SelectDriveA:
 553  8249 3E 01        	ld  a, DRIVE_A
 554  824B 18 02        	jr  SwitchDrive
 555  824D              SelectDriveB:
 556  824D 3E 02        	ld  a, DRIVE_B
 557  824F              SwitchDrive:
 558  824F CD 1C 81     	call SelectDrive
 559  8252 E1           	pop  hl							;restore stack for this call
 560  8253 C3 0F 80     	jp   ReadDiskAgain
 561  8256
 562  8256              NextScr:
 563  8256 21 51 85     	ld hl, ScrPageMsg
 564  8259 3A 53 85     	ld a, (ScrPageMsgMax)
 565  825C BE           	cp (hl)
 566  825D C8           	ret z
 567  825E 34           	inc (hl)
 568  825F C3 E9 81     	jp DisplayFilesLoop
 569  8262
 570  8262              PrevScr:
 571  8262 21 51 85     	ld hl, ScrPageMsg
 572  8265 3E 31        	ld  a, '1'
 573  8267 BE           	cp (hl)
 574  8268 C8           	ret z
 575  8269 35           	dec (hl)
 576  826A C3 E9 81     	jp DisplayFilesLoop
 577  826D
 578  826D
 579  826D              CursorDownOrRight:
 580  826D 3A 1C 86     	ld a, (FileCntScr)
 581  8270 47           	ld b, a
 582  8271 3A 1B 86     	ld a, (SelFileIdxScr)
 583  8274 81           	add c
 584  8275 B8           	cp b
 585  8276 38 06        	jr c, CursorDownValidSelection
 586  8278
 587  8278              	;Cursor moved outside screen, check if we need to move to next screen.
 588  8278 3E 2C        	ld  a, MAX_FILES_SCR
 589  827A B8           	cp  b
 590  827B 28 D9        	jr  z, NextScr
 591  827D C9           	ret
 592  827E
 593  827E              CursorDownValidSelection:
 594  827E              	;The selection is within the file list, draw it.
 595  827E 32 1B 86     	ld (SelFileIdxScr), a
 596  8281 C5           	push bc
 597  8282 F5           	push af
 598  8283 CD B2 82     		call DrawCursor
 599  8286 F1           	pop af
 600  8287 C1           	pop bc
 601  8288 91           	sub c
 602  8289 CD B2 82     	call DrawCursor
 603  828C C9           	ret
 604  828D
 605  828D
 606  828D              CursorDown:
 607  828D 0E 02        	ld  c, 2
 608  828F 18 DC        	jr  CursorDownOrRight
 609  8291
 610  8291              CursorRight:
 611  8291 0E 01        	ld  c, 1
 612  8293 18 D8        	jr  CursorDownOrRight
 613  8295
 614  8295              CursorUp:
 615  8295 0E 02        	ld c, 2
 616  8297 18 04        	jr CursorUpOrLeft
 617  8299
 618  8299              CursorLeft:
 619  8299 0E 01        	ld c, 1
 620  829B 18 00        	jr CursorUpOrLeft
 621  829D
 622  829D              CursorUpOrLeft:
 623  829D 3A 1B 86     	ld a, (SelFileIdxScr)
 624  82A0 B9           	cp c
 625  82A1 38 BF        	jr c, PrevScr
 626  82A3
 627  82A3 C5           	push bc
 628  82A4 F5           	push af
 629  82A5 CD B2 82     		call DrawCursor
 630  82A8 F1           	pop af
 631  82A9 C1           	pop bc
 632  82AA 91           	sub c
 633  82AB 32 1B 86     	ld (SelFileIdxScr), a
 634  82AE CD B2 82     	call DrawCursor
 635  82B1 C9           	ret
 636  82B2
 637  82B2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638  82B2              ;IN A = file index to highlite (0 - 43)
 639  82B2              DrawCursor:
 640  82B2 4F           	ld c, a
 641  82B3 06 00        	ld b, 0
 642  82B5              	;*16
 643  82B5 CB 21        	sla c
 644  82B7 CB 10        	rl b
 645  82B9 CB 21        	sla c
 646  82BB CB 10        	rl b
 647  82BD CB 21        	sla c
 648  82BF CB 10        	rl b
 649  82C1 CB 21        	sla c
 650  82C3 CB 10        	rl b
 651  82C5
 652  82C5 21 00 58     	ld hl, SCR_ATTR_ADDR
 653  82C8 09           	add hl, bc
 654  82C9
 655  82C9 06 10        	ld b, SCR_COLUMNS/2
 656  82CB              DrawCursorLoop:
 657  82CB 7E           	ld a, (hl)
 658  82CC              	;draw inverse
 659  82CC E6 07        	and %111
 660  82CE 4F           	ld  c, a
 661  82CF CB 11        	rl c
 662  82D1 CB 11        	rl c
 663  82D3 CB 11        	rl c
 664  82D5 7E           	ld a, (hl)
 665  82D6 E6 38        	and %111000
 666  82D8 1F           	rra
 667  82D9 1F           	rra
 668  82DA 1F           	rra
 669  82DB B1           	or c
 670  82DC 4F           	ld  c, a
 671  82DD 7E           	ld a, (hl)
 672  82DE              	;keep bright, flash
 673  82DE E6 C0        	and %11000000
 674  82E0 B1           	or c
 675  82E1 77           	ld (hl), a
 676  82E2 23           	inc hl
 677  82E3 10 E6        	djnz DrawCursorLoop
 678  82E5
 679  82E5 C9           	ret
 680  82E6
 681  82E6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 682  82E6              ;Determine the cache line to start with (in HL) and how many files to show (in B)
 683  82E6              ;page1 = files 1-44, page2 = files 45 - 88, page3 = 89 - 128
 684  82E6              GetFileListForScreen:
 685  82E6 3A 17 86     	ld  a, (FileCnt)
 686  82E9 4F           	ld  c, a
 687  82EA 3A 51 85     	ld  a, (ScrPageMsg)
 688  82ED 5F           	ld  e, a
 689  82EE 3A 53 85     	ld a, (ScrPageMsgMax)
 690  82F1 FE 31        	cp '1'
 691  82F3 28 08        	jr  z, OneScreenMax
 692  82F5 FE 32        	cp '2'
 693  82F7 28 08        	jr  z, TwoScreensMax
 694  82F9 FE 33        	cp '3'
 695  82FB 28 17        	jr  z, ThreeScreensMax
 696  82FD
 697  82FD              ;determine file list offset for file list on screen and file count for
 698  82FD              OneScreenMax:
 699  82FD 06 00        	ld  b, 0
 700  82FF 18 30        	jr 	FindCacheLine
 701  8301              TwoScreensMax:
 702  8301 7B           	ld  a, e
 703  8302 FE 32        	cp  '2'
 704  8304 28 06        	jr  z, Page2of2
 705  8306              Page1of2:
 706  8306 06 00        	ld  b, 0					;start from first file for page 1
 707  8308 0E 2C        	ld  c, MAX_FILES_SCR		;display full screen of files, more to come
 708  830A 18 25        	jr  FindCacheLine
 709  830C              Page2of2:
 710  830C 06 2C        	ld  b, MAX_FILES_SCR		;skip first page of files for page 2
 711  830E 79           	ld  a, c
 712  830F D6 2C        	sub MAX_FILES_SCR
 713  8311 4F           	ld  c, a					;get rest of files for page 2
 714  8312 18 1D        	jr 	FindCacheLine
 715  8314              ThreeScreensMax:
 716  8314 7B           	ld  a, e
 717  8315 FE 33        	cp  '3'
 718  8317 28 10        	jr  z, Page3of3
 719  8319 FE 32        	cp  '2'
 720  831B 28 06        	jr  z, Page2of3
 721  831D              Page1of3:
 722  831D 06 00        	ld  b, 0					;start from first file for page 1
 723  831F 0E 2C        	ld  c, MAX_FILES_SCR		;display full page of files, more to come
 724  8321 18 0E        	jr  FindCacheLine
 725  8323              Page2of3:
 726  8323 06 2C        	ld  b, MAX_FILES_SCR		;skip first page of files for page 2
 727  8325 0E 2C        	ld  c, MAX_FILES_SCR		;display full page of files, more to come
 728  8327 18 08        	jr  FindCacheLine
 729  8329              Page3of3:
 730  8329 06 58        	ld  b, 2*MAX_FILES_SCR		;skip first 2 pages of files for page 3
 731  832B 79           	ld  a, c
 732  832C D6 2C        	sub MAX_FILES_SCR
 733  832E D6 2C        	sub MAX_FILES_SCR
 734  8330 4F           	ld  c, a					;get rest of files for page 2
 735  8331
 736  8331              FindCacheLine:
 737  8331 CD 36 83     	call FindCacheByIndex
 738  8334
 739  8334 41           	ld  b, c
 740  8335 C9           	ret
 741  8336
 742  8336              ;IN B=cache index to put in HL
 743  8336              FindCacheByIndex:
 744  8336 11 0D 00     	ld	de, CACHE_LN_SZ
 745  8339 21 1D 86     	ld 	hl, Cache
 746  833C 78           	ld  a, b
 747  833D B7           	or  a
 748  833E C8           	ret z
 749  833F              FindCacheLineLoop:
 750  833F 19           	add	hl, de
 751  8340 10 FD        	djnz FindCacheLineLoop
 752  8342
 753  8342              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 754  8342              ;Shows file lists for one screen, with cache from HL and file count from B
 755  8342              DisplayOneScreen:
 756  8342 C5           	push	bc
 757  8343 E5           	push	hl
 758  8344 3E 02        		ld  a, 2
 759  8346 CD AF 0D     		call ROM_OPEN_SCR_CLR
 760  8349              		;Display occupied space, file number, free space, page
 761  8349 CD B5 84     		call DisplayStats
 762  834C E1           	pop		hl
 763  834D C1           	pop		bc
 764  834E
 765  834E C5           	push 	bc
 766  834F E5           	push 	hl
 767  8350              		;prevent scroll up, to be able to display on row 21
 768  8350 AF           		xor a
 769  8351 32 6B 5C     		ld  (VAR_SCROLL2), a
 770  8354
 771  8354 CD 66 83     		call DisplayFilesInfo
 772  8357
 773  8357              		;restore scroll, to prevent crash
 774  8357 21 6B 5C     		ld  hl, VAR_SCROLL2
 775  835A 36 02        		ld  (hl), 2
 776  835C
 777  835C AF           		xor a
 778  835D 32 1B 86     		ld (SelFileIdxScr), a
 779  8360 CD B2 82     		call DrawCursor
 780  8363 E1           	pop	 hl
 781  8364 C1           	pop  bc
 782  8365
 783  8365 C9           	ret
 784  8366
 785  8366
 786  8366              ;Displays info for each file. A table already contains lines of: FileName, RC count
 787  8366              ;IN HL=file cache line, B=file count
 788  8366              DisplayFilesInfo:
 789  8366 E5           	push hl
 790  8367 3E 02        	ld  a, 2
 791  8369 CD 01 16     	call ROM_OPEN_SCR
 792  836C E1           	pop	hl
 793  836D
 794  836D              	;return if 0 files on disk
 795  836D 78           	ld a, b
 796  836E B7           	or a
 797  836F C8           	ret z
 798  8370              DisplayLoop:
 799  8370 C5           	push bc
 800  8371 E5           	push hl
 801  8372              		;set file name for display
 802  8372 11 A6 85     		ld   de, FileName
 803  8375 D5           		push de
 804  8376 01 0B 00     			ld	 bc, NAMELEN
 805  8379 ED B0        			ldir
 806  837B
 807  837B 4E 23 46 2B  			ld  bc, (hl)
 808  837F 69           			ld  l, c
 809  8380 60           			ld  h, b
 810  8381 CD 9E 81     			call DisplayFileLength
 811  8384 DD E1        		pop  ix
 812  8386
 813  8386 CD BC 83     		call CheckAttributes
 814  8389
 815  8389              		;fix invalid chars in name
 816  8389 06 0B        		ld  b, NAMELEN
 817  838B 21 A6 85     		ld  hl, FileName
 818  838E              FileNameCopy:
 819  838E 7E           		ld  a, (hl)
 820  838F E6 7F        		and $7F									;clear bit 7; LOAD accepts bit 7 set or not (char SCREEN$ or *)
 821  8391 FE 20        		cp  ' '
 822  8393 30 02        		jr  nc, GoodChar
 823  8395 3E 3F        		ld  a, '?'
 824  8397              GoodChar:
 825  8397 77           		ld  (hl), a
 826  8398 23           		inc  hl
 827  8399 10 F3        		djnz FileNameCopy
 828  839B
 829  839B              		;display line
 830  839B 21 9D 85     		ld hl, DisplayedLine
 831  839E 06 1B        		ld b, DisplayedLineEnd-DisplayedLine	;how many chars on one line
 832  83A0 CD 27 80     		call PrintStr
 833  83A3
 834  83A3              		;set tab every 2 entries
 835  83A3 3A 9E 85     		ld a, (TabChar)
 836  83A6 EE 10        		xor SCR_COLUMNS/2
 837  83A8 32 9E 85     		ld (TabChar), a
 838  83AB E1           	pop hl
 839  83AC 01 0D 00     	ld  bc, CACHE_LN_SZ
 840  83AF 09           	add hl, bc
 841  83B0 C1           	pop bc
 842  83B1
 843  83B1              	;set alternating bright every 2 entries
 844  83B1 78           	ld a, b
 845  83B2 E6 02        	and 2
 846  83B4 CB 3F        	srl a
 847  83B6 32 A3 85     	ld (DisplayedBright), a
 848  83B9 10 B5        	djnz DisplayLoop
 849  83BB
 850  83BB C9           	ret
 851  83BC
 852  83BC
 853  83BC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 854  83BC
 855  83BC              ;Checks the attributes and reset the bits, saving result as color attribute
 856  83BC              ;IX=file name
 857  83BC              CheckAttributes:
 858  83BC 3E 05        	ld  a, CLR_NAME
 859  83BE DD CB 08 7E  	bit 7, (ix+ATTR_RO_POS)
 860  83C2 28 06        	jr  z, NotRO
 861  83C4 DD CB 08 BE  	res 7, (ix+ATTR_RO_POS)
 862  83C8 3E 02        	ld  a, CLR_RO
 863  83CA              NotRO:
 864  83CA DD CB 09 7E  	bit 7, (ix+ATTR_SYS_POS)
 865  83CE 28 0E        	jr  z, NotSys
 866  83D0 DD CB 09 BE  	res 7, (ix+ATTR_SYS_POS)
 867  83D4 FE 02        	cp  CLR_RO
 868  83D6 28 04        	jr  z, BothAttr
 869  83D8 3E 03        	ld  a, CLR_SYS
 870  83DA 18 02        	jr  NotSys
 871  83DC              BothAttr:
 872  83DC 3E 04        	ld  a, CLR_RO_SYS
 873  83DE              NotSys:
 874  83DE 32 A5 85     	ld (FileNameClr), a
 875  83E1 C9           	ret
 876  83E2
 877  83E2
 878  83E2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 879  83E2
 880  83E2              ;Read directory and create a table (name - 11B, RC count - 2B)
 881  83E2              ReadCatalog1:
 882  83E2 AF           	xor a
 883  83E3 6F           	ld l, a
 884  83E4 67           	ld h, a
 885  83E5 22 18 86     	ld (UsedKB), hl					;reset used blocks
 886  83E8 32 17 86     	ld (FileCnt), a					;reset file counter
 887  83EB 3E 80        	ld  a, MAX_DIR_ENT
 888  83ED 32 1A 86     	ld (FreeCatalog), a
 889  83F0
 890  83F0 21 0B 86     	ld hl, FileMask
 891  83F3 3A 16 86     	ld a, (DRIVE_SELECTED)
 892  83F6 47           	ld b, a							;drive
 893  83F7 0E 0B        	ld c, NAMELEN					;name len
 894  83F9 CD F1 80     	call CreateChannel
 895  83FC CD 36 81     	call SetDMA
 896  83FF
 897  83FF 3E 00        	ld	a, 0						;request first extension
 898  8401 DD 77 0C     	ld (ix + FCB_EX_IDX), a
 899  8404
 900  8404 CD 2E 81     	call FindFirst
 901  8407 11 1D 86     	ld de, Cache
 902  840A
 903  840A              CatNext:
 904  840A 3C           	inc a
 905  840B 28 33        	jr z, CatEnd			;return if A=FFh
 906  840D 3D           	dec a
 907  840E
 908  840E DD E5        	push ix
 909  8410 01 26 00     		ld bc, CH_DMA
 910  8413 DD 09        		add ix, bc
 911  8415
 912  8415              		;A is the index for the 32 byte dir. entry in DMA buffer
 913  8415 17           		rla
 914  8416 17           		rla
 915  8417 17           		rla
 916  8418 17           		rla
 917  8419 17           		rla
 918  841A 06 00        		ld b, 0
 919  841C 4F           		ld c, a
 920  841D DD 09        		add ix, bc						;hl=file name -1=FCB
 921  841F
 922  841F              		;put name in cache
 923  841F DD E5        		push ix
 924  8421 E1           		pop hl
 925  8422 23           		inc hl						;HL = file name
 926  8423 01 0B 00     		ld  bc, NAMELEN
 927  8426 ED B0        		ldir
 928  8428
 929  8428              		;skip EX, S1, S2
 930  8428 23           		inc hl
 931  8429 23           		inc hl
 932  842A 23           		inc hl
 933  842B              		;save RC count for first extension
 934  842B ED A0        		ldi
 935  842D AF           		xor a
 936  842E 12           		ld (de), a
 937  842F 13           		inc de
 938  8430 DD E1        	pop  ix
 939  8432
 940  8432 3A 17 86     	ld a, (FileCnt)
 941  8435 3C           	inc a
 942  8436 32 17 86     	ld (FileCnt), a
 943  8439
 944  8439              	;find next file
 945  8439 D5           	push de
 946  843A CD 32 81     		call FindNext
 947  843D D1           	pop de
 948  843E
 949  843E 18 CA        	jr CatNext
 950  8440              CatEnd:
 951  8440
 952  8440 CD 06 81     	call DestroyChannel
 953  8443 C9           	ret
 954  8444
 955  8444
 956  8444              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 957  8444              ;Will ignore extensions with index 0, will add up RC count for subsequent extensions.
 958  8444              ReadCatalog2:
 959  8444 21 0B 86     	ld hl, FileMask
 960  8447 3A 16 86     	ld a, (DRIVE_SELECTED)
 961  844A 47           	ld b, a							;drive
 962  844B 0E 0B        	ld c, NAMELEN					;name len
 963  844D CD F1 80     	call CreateChannel
 964  8450 CD 36 81     	call SetDMA
 965  8453
 966  8453 3E 3F        	ld	a, '?'						;request all extensions
 967  8455 DD 77 0C     	ld (ix + FCB_EX_IDX), a
 968  8458
 969  8458 CD 2E 81     	call FindFirst
 970  845B
 971  845B              CatNext2:
 972  845B 3C           	inc a
 973  845C 28 3E        	jr z, CatEnd2			;return if A=FFh
 974  845E 3D           	dec a
 975  845F
 976  845F 21 1A 86     	ld hl, FreeCatalog
 977  8462 35           	dec (hl)
 978  8463
 979  8463 DD E5        	push ix
 980  8465 01 26 00     		ld bc, CH_DMA
 981  8468 DD 09        		add ix, bc
 982  846A
 983  846A              		;A is the index for the 32 byte dir. entry in DMA buffer
 984  846A 17           		rla
 985  846B 17           		rla
 986  846C 17           		rla
 987  846D 17           		rla
 988  846E 17           		rla
 989  846F 06 00        		ld b, 0
 990  8471 4F           		ld c, a
 991  8472 DD 09        		add ix, bc						;hl=file name -1=FCB
 992  8474
 993  8474              		;now ignore entries with index 0, as these are already processed
 994  8474 DD 7E 0C     		ld  a, (ix + FCB_EX_IDX)
 995  8477 B7           		or  a
 996  8478 28 1B        		jr  z, Cat2Index0
 997  847A
 998  847A              		;find cache for this file
 999  847A DD E5        		push ix
1000  847C E1           		pop  hl
1001  847D 23           		inc  hl
1002  847E CD A0 84     		call FindCacheByName
1003  8481
1004  8481 EB           		ex  de, hl
1005  8482 01 0B 00     		ld  bc, NAMELEN
1006  8485 09           		add hl, bc
1007  8486
1008  8486              		;add RC count in cache
1009  8486 4E           		ld  c, (hl)
1010  8487 23           		inc hl
1011  8488 46           		ld  b, (hl)
1012  8489 2B           		dec hl
1013  848A EB           		ex  de, hl
1014  848B DD 6E 0F     		ld  l, (ix + FCB_RC)
1015  848E 26 00        		ld  h, 0
1016  8490 09           		add hl, bc
1017  8491 EB           		ex  de, hl
1018  8492 73           		ld  (hl), e
1019  8493 23           		inc hl
1020  8494 72           		ld  (hl), d
1021  8495              Cat2Index0:
1022  8495 DD E1        	pop  ix
1023  8497
1024  8497 CD 32 81     	call FindNext
1025  849A
1026  849A 18 BF        	jr CatNext2
1027  849C              CatEnd2:
1028  849C
1029  849C CD 06 81     	call DestroyChannel
1030  849F C9           	ret
1031  84A0
1032  84A0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1033  84A0              ;IN HL = name address
1034  84A0              ;OUT DE = file row in cache
1035  84A0              FindCacheByName:
1036  84A0 11 1D 86     	ld  de, Cache
1037  84A3
1038  84A3              FindCacheLoop:
1039  84A3 E5           	push hl
1040  84A4 D5           	push de
1041  84A5 06 0B        		ld  b, NAMELEN
1042  84A7 CD 3C 80     		call StrCmp
1043  84AA D1           	pop  de
1044  84AB E1           	pop  hl
1045  84AC C8           	ret z
1046  84AD
1047  84AD              	;skip RC count in cache
1048  84AD EB           	ex  de, hl
1049  84AE 01 0D 00     	ld  bc, CACHE_LN_SZ
1050  84B1 09           	add hl, bc
1051  84B2 EB           	ex  de, hl
1052  84B3 18 EE        	jr  FindCacheLoop
1053  84B5
1054  84B5
1055  84B5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1056  84B5
1057  84B5              ;Displays free space
1058  84B5              DisplayStats:
1059  84B5 2A 18 86     	ld   hl, (UsedKB)
1060  84B8 E5           	push hl
1061  84B9 11 7E 85     		ld de, UsedSpaceAsc
1062  84BC CD FA 84     		call N2ASCII3
1063  84BF C1           	pop  bc
1064  84C0
1065  84C0 21 7C 02     	ld  hl, (MAX_FREE_AU_CNT * AU_SZ)/1024
1066  84C3 B7 ED 42     	sub hl, bc
1067  84C6 11 90 85     	ld de, FreeSpaceAsc
1068  84C9 CD FA 84     	call N2ASCII3
1069  84CC
1070  84CC 3A 17 86     	ld a, (FileCnt)
1071  84CF 26 00        	ld h, 0
1072  84D1 6F           	ld l, a
1073  84D2 11 84 85     	ld de, FileCntMsg
1074  84D5 CD FA 84     	call N2ASCII3
1075  84D8
1076  84D8 3A 16 86     	ld  a, (DRIVE_SELECTED)
1077  84DB C6 40        	add 'A'-1
1078  84DD 32 79 85     	ld  (MsgDrive), a
1079  84E0
1080  84E0 3A 1A 86     	ld a, (FreeCatalog)
1081  84E3 6F           	ld l, a
1082  84E4 26 00        	ld h, 0
1083  84E6 11 96 85     	ld de, UsedCatMsg
1084  84E9 CD FA 84     	call N2ASCII3
1085  84EC
1086  84EC              PrintStats:
1087  84EC 3E 00        	ld	a, 0
1088  84EE CD 01 16     	call ROM_OPEN_SCR
1089  84F1 21 45 85     	ld hl, FreeSpaceMsg
1090  84F4 06 58        	ld b, FreeSpaceMsgEnd - FreeSpaceMsg
1091  84F6 CD 27 80     	call PrintStr
1092  84F9 C9           	ret
1093  84FA
1094  84FA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Number routines ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1095  84FA
1096  84FA              ;Converts the 3 digit number in HL to ASCII at DE
1097  84FA              N2ASCII3:
1098  84FA D5           	push de
1099  84FB CD 2B 85     		call N2ASCII_DEC3
1100  84FE D1           	pop de
1101  84FF 01 00 02     	ld  bc, $0200
1102  8502 18 08        	jr StrippLoop
1103  8504
1104  8504              ;Converts the 5 digit number in HL to ASCII
1105  8504              N2ASCII5:
1106  8504 D5           	push de
1107  8505 CD 1F 85     		call N2ASCII_DEC
1108  8508 D1           	pop de
1109  8509
1110  8509              StrippLeading0:
1111  8509 01 00 04     	ld bc, $0400
1112  850C              	;ld c, 0
1113  850C              StrippLoop:
1114  850C 1A           	ld a, (de)
1115  850D FE 30        	cp '0'
1116  850F 20 09        	jr nz, MarkNon0
1117  8511 79           	ld a, c
1118  8512              	;cp 0
1119  8512 B7           	or a
1120  8513 20 06        	jr nz, NextChar
1121  8515 3E 20        	ld a, ' '
1122  8517 12           	ld (de), a
1123  8518 18 01        	jr NextChar
1124  851A              MarkNon0:
1125  851A 0C           	inc c
1126  851B              NextChar:
1127  851B 13           	inc de
1128  851C 10 EE        	djnz StrippLoop
1129  851E C9           	ret
1130  851F
1131  851F
1132  851F              ;The folowing routine was inspired from: Milos "baze" Bazelides, baze@stonline.sk
1133  851F              ;http://map.tni.nl/sources/external/z80bits.html
1134  851F
1135  851F              ;Converts the number in HL to ASCII in decimal string at DE
1136  851F              N2ASCII_DEC:
1137  851F 01 F0 D8     	ld bc, -10000
1138  8522 CD 3A 85     	call DigitLoop
1139  8525 01 18 FC     	ld bc, -1000
1140  8528 CD 3A 85     	call DigitLoop
1141  852B              N2ASCII_DEC3:
1142  852B 01 9C FF     	ld bc, -100
1143  852E CD 3A 85     	call DigitLoop
1144  8531 01 F6 FF     	ld bc, -10
1145  8534 CD 3A 85     	call DigitLoop
1146  8537 01 FF FF     	ld bc, -1
1147  853A
1148  853A              DigitLoop:
1149  853A 3E 2F        	ld	a, '0' - 1
1150  853C              DivNrLoop:
1151  853C 3C           	inc	a			;increase reminder
1152  853D 09           	add	hl, bc		;substract divizor
1153  853E 38 FC        	jr	c, DivNrLoop	;still dividing?
1154  8540 ED 42        	sbc	hl, bc		;nope, restore
1155  8542
1156  8542 12           	ld (de), a
1157  8543 13           	inc de
1158  8544 C9           	ret
1159  8545
1160  8545
1161  8545              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Allocated Data ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1162  8545
1163  8545              FreeSpaceMsg:
1164  8545 14 01        				DEFB	CLR_CODE_INVERSE, 1
1165  8547 13 01        				DEFB	CLR_CODE_BRIGHT, 1
1166  8549 11 01        				DEFB	CLR_CODE_PAPER, CLR_BLUE
1167  854B 10 06        				DEFB	CLR_CODE_INK, CLR_YELLOW
1168  854D 50 61 67 65  				DEFB	"Page"
1169  8551 31 2F        ScrPageMsg		DEFB	"1/"
1170  8553 31           ScrPageMsgMax	DEFB	"1"
1171  8554 10 05 4E 61  				DEFB	CLR_CODE_INK, CLR_NAME, "Name"
1171  8558 6D 65
1172  855A 10 06 4C 65  				DEFB	CLR_CODE_INK, CLR_LEN, "Len B"
1172  855E 6E 20 42
1173  8561 10 02 2B 52  				DEFB    CLR_CODE_INK, CLR_RO, "+R/O"
1173  8565 2F 4F
1174  8567 10 03 2B 53  				DEFB 	CLR_CODE_INK, CLR_SYS, "+SYS"
1174  856B 59 53
1175  856D 10 04 2B 52  				DEFB 	CLR_CODE_INK, CLR_RO_SYS, "+R/O+SYS"
1175  8571 2F 4F 2B 53
1175  8575 59 53
1176  8577
1177  8577 10 05        				DEFB	CLR_CODE_INK, CLR_CYAN
1178  8579 41 3A 20     MsgDrive		DEFB	"A: "
1179  857C 10 02        				DEFB	CLR_CODE_INK, CLR_RED
1180  857E 20 20 20 4B  UsedSpaceAsc	DEFM	"   KB/"
1180  8582 42 2F
1181  8584 20 20 20 20  FileCntMsg		DEFM    "    files,"
1181  8588 66 69 6C 65
1181  858C 73 2C
1182  858E 10 04        				DEFB	CLR_CODE_INK, CLR_GREEN
1183  8590 20 20 20 4B  FreeSpaceAsc	DEFM	"   KB/"
1183  8594 42 2F
1184  8596 20 20 20 20  UsedCatMsg		DEFM 	"    dir"
1184  859A 64 69 72
1185  859D              FreeSpaceMsgEnd:
1186  859D
1187  859D
1188  859D              DisplayedLine:
1189  859D 17           				DEFB	CLR_CODE_TAB						;tab
1190  859E 00 00        TabChar			DEFB	0, 0
1191  85A0 11 01        				DEFB	CLR_CODE_PAPER, CLR_BLUE
1192  85A2 13           				DEFM	CLR_CODE_BRIGHT
1193  85A3 00           DisplayedBright	DEFB	0				;bright is alternating
1194  85A4 10           				DEFB	CLR_CODE_INK
1195  85A5 05           FileNameClr		DEFB	CLR_NAME
1196  85A6 3F 3F 3F 3F  FileName		DEFM	"???????????"
1196  85AA 3F 3F 3F 3F
1196  85AE 3F 3F 3F
1197  85B1 10 06        				DEFB	CLR_CODE_INK, CLR_LEN
1198  85B3 20 20 20 20  FileLen			DEFB	"     "
1198  85B7 20
1199  85B8              DisplayedLineEnd:
1200  85B8
1201  85B8 11 02 13 01  MsgError		DEFB	CLR_CODE_PAPER, CLR_RED, CLR_CODE_BRIGHT, 1
1202  85BC 45 72 72 6F  				DEFM	"Error "
1202  85C0 72 20
1203  85C2 20 20 20 3A  MsgErrCode		DEFM	"   : "
1203  85C6 20
1204  85C7              MsgErrorEnd
1205  85C7
1206  85C7 14 01 10 02  MsgIntro		DEFM	CLR_CODE_INVERSE, 1, CLR_CODE_INK, CLR_RED
1207  85CB 43 75 72 73  				DEFM	"Cursor+CR=Run;1/2=A:/B:;ESC=Exit"
1207  85CF 6F 72 2B 43
1207  85D3 52 3D 52 75
1207  85D7 6E 3B 31 2F
1207  85DB 32 3D 41 3A
1207  85DF 2F 42 3A 3B
1207  85E3 45 53 43 3D
1207  85E7 45 78 69 74
1208  85EB 7F 32 30 32  				DEFM	127, "2022 george.chirtoaca@gmail.com"
1208  85EF 32 20 67 65
1208  85F3 6F 72 67 65
1208  85F7 2E 63 68 69
1208  85FB 72 74 6F 61
1208  85FF 63 61 40 67
1208  8603 6D 61 69 6C
1208  8607 2E 63 6F 6D
1209  860B              MsgIntroEnd:
1210  860B
1211  860B              ;the search mask
1212  860B 3F 3F 3F 3F  FileMask		DEFM	"???????????"
1212  860F 3F 3F 3F 3F
1212  8613 3F 3F 3F
1213  8616 00           DRIVE_SELECTED	DEFB	DRIVE_CURRENT		;0=A:, 1=B: for BDOS, 0 = use current drive for BASIC; can be poked with the desired drive, it's the last byte in block
1214  8617              END
1215  8617
1216  8617              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Unalocated Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217  8617
1218  8617              FileCnt			EQU		DRIVE_SELECTED + 1		;file index for display
1219  8617              UsedKB			EQU		FileCnt + 1
1220  8617              FreeCatalog		EQU		UsedKB + 2
1221  8617              SelFileIdxScr	EQU		FreeCatalog + 1
1222  8617              FileCntScr		EQU		SelFileIdxScr + 1
1223  8617              Cache			EQU		FileCntScr + 1				;here goes the cache table
1224  8617
1225  8617              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1226  8617
1227  8617              START_ADDR		EQU	$8000		;Start address
1228  8617
1229  8617              ;System variables for disk
1230  8617              VAR_DSTR1		EQU	$5CD6		;drive
1231  8617              VAR_FSTR1		EQU	$5CDC		;file name
1232  8617              VAR_NSTR1		EQU	$5CDA		;name length
1233  8617              VAR_HD11		EQU	$5CED		;BDOS argument
1234  8617              VAR_COPIES		EQU	$5CEF		;BDOS function
1235  8617              VAR_IOBORD		EQU	23750		;IO border
1236  8617              VAR_ATTR		EQU 23693		;color attribute
1237  8617              VAR_BORDCR		EQU 23624
1238  8617
1239  8617              VAR_SCROLL		EQU	23692
1240  8617              VAR_SCROLL2		EQU	23659
1241  8617              VAR_BORDER		EQU	$5C47
1242  8617              VAR_ERRSP		EQU $5C3D
1243  8617              VAR_ERRNR		EQU $5C3A
1244  8617              VAR_REPDEL		EQU	23561
1245  8617
1246  8617              ;IF1
1247  8617              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
1248  8617              ERRMSG			EQU	$0260
1249  8617
1250  8617              DRIVE_CURRENT	EQU 0
1251  8617              DRIVE_A			EQU	1
1252  8617              DRIVE_B			EQU	2
1253  8617
1254  8617              ;File name stuff
1255  8617              NAMELEN			EQU	11			;name length
1256  8617              ATTR_RO_POS		EQU	8			;read-only attribute position in name
1257  8617              ATTR_SYS_POS	EQU	9			;system attribute position in name
1258  8617
1259  8617              ;Disk geometry stuff
1260  8617              SPT				EQU	16			;sectors per track
1261  8617              SECT_SZ			EQU	256			;sector size in bytes
1262  8617              TRACK_CNT		EQU	80			;track count
1263  8617              HEAD_CNT		EQU	2			;disk face count
1264  8617              AU_SZ			EQU	2048		;allocation unit size in bytes
1265  8617              DIR_ENT_SZ		EQU	32			;directory entry size
1266  8617              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
1267  8617              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
1268  8617              MAX_DIR_ENT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / DIR_ENT_SZ);maximum directory entries
1269  8617              MAX_AU_CNT		EQU	(TRACK_CNT * HEAD_CNT * SPT * SECT_SZ)/AU_SZ
1270  8617              MAX_FREE_AU_CNT	EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units
1271  8617              REC_SZ			EQU 128			;cp/m record size
1272  8617              FINISH_CHR		EQU $1A			;file terminator char
1273  8617
1274  8617              ;File header offsets
1275  8617              HDR_TYPE		EQU	0
1276  8617              HDR_LEN			EQU 1
1277  8617              HDR_ADDR		EQU 3
1278  8617              HDR_VAR			EQU	5
1279  8617              HDR_LINE		EQU 7
1280  8617              HDR_SIZE		EQU 9
1281  8617
1282  8617              ;Disk cache table structure
1283  8617              CACHE_NAME		EQU 0
1284  8617              CACHE_RC_CNT	EQU NAMELEN
1285  8617              CACHE_LN_SZ		EQU NAMELEN +2
1286  8617
1287  8617              ;BASIC disk channel structure
1288  8617              CH_RW_FLAG		EQU 11
1289  8617              CH_FCB			EQU	12
1290  8617              CH_DATA			EQU	50
1291  8617              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
1292  8617
1293  8617              ;Extension structure (directory entry)
1294  8617              EXT_DEL_FLAG	EQU	0
1295  8617              EXT_NAME		EQU 1
1296  8617              EXT_IDX			EQU 12
1297  8617              EXT_S1			EQU 13
1298  8617              EXT_S2			EQU 14
1299  8617              EXT_RC			EQU	15
1300  8617              EXT_AU0			EQU	16
1301  8617              EXT_AU1			EQU	18
1302  8617              EXT_AU2			EQU	20
1303  8617              EXT_AU3			EQU	22
1304  8617              EXT_AU4			EQU	24
1305  8617              EXT_AU5			EQU	26
1306  8617              EXT_AU6			EQU	28
1307  8617              EXT_AU7			EQU	30
1308  8617              EXT_AU_CNT		EQU 8
1309  8617
1310  8617              ;FCB structure
1311  8617              FCB_DRIVE		EQU 0			;0 is current drive
1312  8617              FCB_NAME		EQU EXT_NAME
1313  8617              FCB_EX_IDX		EQU EXT_IDX
1314  8617              FCB_S1			EQU EXT_S1
1315  8617              FCB_S2			EQU EXT_S2
1316  8617              FCB_RC			EQU	EXT_RC
1317  8617              FCB_AU			EQU	EXT_AU0
1318  8617              FCB_CR			EQU	32
1319  8617              FCB_R0			EQU 33
1320  8617              FCB_R1			EQU 34
1321  8617              FCB_R2			EQU 35
1322  8617
1323  8617              ROM_OPEN_SCR	EQU	$1601
1324  8617              ROM_OPEN_SCR_CLR	EQU	$0DAF
1325  8617              ROM_PRINT		EQU $203C		;DE = string, BC = len
1326  8617
1327  8617              CLR_CODE_INK	EQU 16
1328  8617              CLR_CODE_PAPER	EQU 17
1329  8617              CLR_CODE_BRIGHT EQU	19
1330  8617              CLR_CODE_INVERSE EQU	20
1331  8617              CLR_CODE_TAB	EQU 23
1332  8617
1333  8617              CLR_BLACK		EQU	0
1334  8617              CLR_BLUE		EQU	1
1335  8617              CLR_RED			EQU	2
1336  8617              CLR_MAGENTA		EQU	3
1337  8617              CLR_GREEN		EQU	4
1338  8617              CLR_CYAN		EQU	5
1339  8617              CLR_YELLOW		EQU	6
1340  8617              CLR_WHITE		EQU	7
1341  8617
1342  8617              CLR_NAME		EQU CLR_CYAN
1343  8617              CLR_RO			EQU	CLR_RED
1344  8617              CLR_SYS			EQU	CLR_MAGENTA
1345  8617              CLR_RO_SYS		EQU	CLR_GREEN
1346  8617              CLR_LEN			EQU	CLR_YELLOW
1347  8617
1348  8617              SCR_ATTR_ADDR	EQU 22528
1349  8617              SCR_ATTR_LEN	EQU	768
1350  8617              SCR_COLUMNS		EQU	32
1351  8617              SCR_LINES		EQU 24
1352  8617
1353  8617              ;key codes
1354  8617              KEY_ESC			EQU	7
1355  8617              KEY_LEFT		EQU	8
1356  8617              KEY_RIGHT		EQU	9
1357  8617              KEY_DOWN		EQU	10
1358  8617              KEY_UP			EQU	11
1359  8617              KEY_ENTER		EQU	13
1360  8617              KEY_CTRL		EQU	14
1361  8617
1362  8617              MAX_FILES_SCR	EQU	44
1363  8617
1364  8617
1365  8617              				EMPTYTAP "cat.tap"
1366  8617              				savetap "cat.tap", CODE, "run", start, END-start
1367  8617              ;				savebin "cat.bin", start, END-start
1368  8617
# file closed: D:\Spectrum\src\HC\HCRun\cat.ASM

Value    Label
------ - -----------------------------------------------------------
0x000E X KEY_CTRL
0x0018 X SCR_LINES
0x0300 X SCR_ATTR_LEN
0x0003   CLR_MAGENTA
0x0000 X CLR_BLACK
0x203C X ROM_PRINT
0x0023 X FCB_R2
0x0022 X FCB_R1
0x0021 X FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000E X FCB_S2
0x000D X FCB_S1
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0008 X EXT_AU_CNT
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x000C   EXT_IDX
0x0001   EXT_NAME
0x0000 X EXT_DEL_FLAG
0x0032   CH_DATA
0x000B X CH_RW_FLAG
0x000B X CACHE_RC_CNT
0x0000 X CACHE_NAME
0x0009 X HDR_SIZE
0x0007 X HDR_LINE
0x0005 X HDR_VAR
0x0003 X HDR_ADDR
0x0001 X HDR_LEN
0x0000 X HDR_TYPE
0x001A X FINISH_CHR
0x0080 X REC_SZ
0x0140 X MAX_AU_CNT
0x0008 X SPAL
0x0001   DIR_TRK_CNT
0x0020   DIR_ENT_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0100   SECT_SZ
0x0010   SPT
0x5C47 X VAR_BORDER
0x5C8C X VAR_SCROLL
0x5CC6 X VAR_IOBORD
0x8617 X END
0x0017   CLR_CODE_TAB
0x0004   CLR_GREEN
0x0002   CLR_RED
0x0005   CLR_CYAN
0x0006   CLR_LEN
0x0006   CLR_YELLOW
0x0010   CLR_CODE_INK
0x0011   CLR_CODE_PAPER
0x0013   CLR_CODE_BRIGHT
0x0014   CLR_CODE_INVERSE
0x853C   DivNrLoop
0x853A   DigitLoop
0x851B   NextChar
0x851A   MarkNon0
0x8509 X StrippLeading0
0x851F   N2ASCII_DEC
0x850C   StrippLoop
0x852B   N2ASCII_DEC3
0x859D   FreeSpaceMsgEnd
0x8545   FreeSpaceMsg
0x84EC X PrintStats
0x8596   UsedCatMsg
0x8579   MsgDrive
0x8584   FileCntMsg
0x8590   FreeSpaceAsc
0x0800   AU_SZ
0x013E   MAX_FREE_AU_CNT
0x857E   UsedSpaceAsc
0x84A3   FindCacheLoop
0x000F   FCB_RC
0x84A0   FindCacheByName
0x8495   Cat2Index0
0x849C   CatEnd2
0x845B   CatNext2
0x8440   CatEnd
0x840A   CatNext
0x000C   FCB_EX_IDX
0x860B   FileMask
0x861A   FreeCatalog
0x0080   MAX_DIR_ENT
0x85A5   FileNameClr
0x0004   CLR_RO_SYS
0x0003   CLR_SYS
0x83DC   BothAttr
0x83DE   NotSys
0x0009   ATTR_SYS_POS
0x0002   CLR_RO
0x83CA   NotRO
0x0008   ATTR_RO_POS
0x0005   CLR_NAME
0x85A3   DisplayedBright
0x85B8   DisplayedLineEnd
0x859D   DisplayedLine
0x8397   GoodChar
0x838E   FileNameCopy
0x83BC   CheckAttributes
0x85A6   FileName
0x8370   DisplayLoop
0x8366   DisplayFilesInfo
0x5C6B   VAR_SCROLL2
0x833F   FindCacheLineLoop
0x000D   CACHE_LN_SZ
0x831D X Page1of3
0x8323   Page2of3
0x8329   Page3of3
0x8306 X Page1of2
0x830C   Page2of2
0x8331   FindCacheLine
0x8314   ThreeScreensMax
0x8301   TwoScreensMax
0x82FD   OneScreenMax
0x82CB   DrawCursorLoop
0x0020   SCR_COLUMNS
0x5800   SCR_ATTR_ADDR
0x829D   CursorUpOrLeft
0x82B2   DrawCursor
0x827E   CursorDownValidSelection
0x826D   CursorDownOrRight
0x8262   PrevScr
0x8256   NextScr
0x0002   DRIVE_B
0x824F   SwitchDrive
0x8336   FindCacheByIndex
0x861B   SelFileIdxScr
0x8238   PageAddLoop
0x823C   FirstPageIndex
0x000D   KEY_ENTER
0x8299   CursorLeft
0x822A   CheckEnter
0x0008   KEY_LEFT
0x8291   CursorRight
0x8221   CheckKeyLeft
0x0009   KEY_RIGHT
0x8295   CursorUp
0x8218   CheckKeyRight
0x000B   KEY_UP
0x828D   CursorDown
0x820F   CheckKeyUp
0x000A   KEY_DOWN
0x824D   SelectDriveB
0x8249   SelectDriveA
0x0007   KEY_ESC
0x8342   DisplayOneScreen
0x861C   FileCntScr
0x82E6   GetFileListForScreen
0x859E   TabChar
0x81E9   DisplayFilesLoop
0x002C   MAX_FILES_SCR
0x81E3   ScreenCntLoop
0x84B5   DisplayStats
0x81E0   NonEmptyDisk
0x8553   ScrPageMsgMax
0x8551   ScrPageMsg
0x8504   N2ASCII5
0x85B3   FileLen
0x81B9   BigFile
0x819E   DisplayFileLength
0x8199   NoPartialAU
0x8618   UsedKB
0x8180   GetFileSizeOnDiskKB
0x8164   FileSizeLoop
0x8617   FileCnt
0x0A41   LOAD_ADDR
0x0000   DRIVE_CURRENT
0x000B   NAMELEN
0x8145   LoadProgram
0x0026   CH_DMA
0x8136   SetDMA
0x8132   FindNext
0x812E   FindFirst
0x8616   DRIVE_SELECTED
0x5CEF   VAR_COPIES
0x810E   BDOS
0x8106   DestroyChannel
0x000C   CH_FCB
0x5CDA   VAR_NSTR1
0x5CD6   VAR_DSTR1
0x5CDC   VAR_FSTR1
0x80F1   CreateChannel
0x80E0   CopyMsg
0x80D2   SearchMsgEnd
0x80DB   SaveMsg
0x0260   ERRMSG
0x5CED   VAR_HD11
0x80C9   IF1Paged
0x80B8   DontSelectA
0x861D   Cache
0x80BE   GetErrMsg
0x85C7   MsgErrorEnd
0x85B8   MsgError
0x84FA   N2ASCII3
0x85C2   MsgErrCode
0x5C3A   VAR_ERRNR
0x860B   MsgIntroEnd
0x85C7   MsgIntro
0x1601   ROM_OPEN_SCR
0x0DAF   ROM_OPEN_SCR_CLR
0x5C8D   VAR_ATTR
0x5C48   VAR_BORDCR
0x0007   CLR_WHITE
0x0001   CLR_BLUE
0x811C   SelectDrive
0x0001   DRIVE_A
0x805B   SelectDriveInit
0x8059   CurrentDriveNone
0x812A   GetCurrentDrive
0x8118   InitDos
0x80EE   InitVars
0x8046   MisMatch
0x803E   Compare
0x803C   StrCmp
0x5C09   VAR_REPDEL
0x8031   SetFastKeys
0x8027   PrintStr
0x8024   ReadChar
0x81F8   ReadCharLoop
0x81CB   DisplayFiles
0x815D   GetDiskUsedSpace
0x8444   ReadCatalog2
0x83E2   ReadCatalog1
0x800F   ReadDiskAgain
0x8049   Init
0x8080   ErrorHandler
0x5C3D   VAR_ERRSP
0x8000   start
0x8000   START_ADDR
